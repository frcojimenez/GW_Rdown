(* ::Package:: *)

(************************************************************************)
(* This file was generated automatically by the Mathematica front end.  *)
(* It contains Initialization cells from a Notebook file, which         *)
(* typically will have the same name as this file except ending in      *)
(* ".nb" instead of ".m".                                               *)
(*                                                                      *)
(* This file is intended to be loaded into the Mathematica kernel using *)
(* the package loading commands Get or Needs.  Doing so is equivalent   *)
(* to using the Evaluate Initialization Cells menu command in the front *)
(* end.                                                                 *)
(*                                                                      *)
(* DO NOT EDIT THIS FILE.  This entire file is regenerated              *)
(* automatically each time the parent Notebook file is saved in the     *)
(* Mathematica front end.  Any changes you make to this file will be    *)
(* overwritten.                                                         *)
(************************************************************************)



(* Probably not all the extra packages are really needed *)
BeginPackage["RDown`"];


(*Print["Starting Python session." ,session = StartExternalSession["Python"]];
ExternalEvaluate[session, "import qnm; import numpy as np"];*)


EasyMatchT::usage="EasyMatchT[h1_,h2_,tMin_,tMax_]. Time domain version of the match as in eq. (2) of 1903.08284. tMin and tMax are the time interval where to compute the match.";
PlanckTaper::usage="PlanckTaper[t,t1,t2] is the one-sided version of the tapering function described in CQG27:084020, arXiv:1003.2939 [gr-qc].";
TimeOfMaximum::usage="TimeOfMaximum[list_?ListQ] determines the time at which a time series reaches the absolute maximum of the modulus.";
GetAsymptoticMultiMode::usage="GetAsymptoticMode[h5file_,order_,modes_list,OptionsPattern[{\"Verbose\"\[Rule]False}]].";
EradUIB2017::usage="EradUIB2017[\[Eta]_,\[Chi]1_,\[Chi]2_] is fit for the energy radiated of the coalescence of 2 non-precessing quasicurcular BHs as in PRD:DY11536";
FinalSpinUIB2017::usage="FinalSpinUIB2017[\[Eta]_,\[Chi]1_,\[Chi]2_] is fit for the final spin of the coalescence of 2 non-precessing quasicurcular BHs as in PRD:DY11536";
IsFPNumberQ::usage="IsFPNumberQ[str_String] checks whether a string represents a real Number.";
ReadFloatingPointNumbers::usage="ReadFloatingPointNumbers[line_String, matchAnyFP_:True] converts string that contains a Fortran or C-style floating point number to a Mathematica Number.";
StringToNumber::usage="StringToNumber[x_] converts a String x to a number, allowing more general number formats than ToExpression.";
SXSMetaFilesToRules::usage="SXSMetaFilesToRules[filename_String] converts a SXS metadata.txt file to a list of rules.";
SXSParClassification::usage="SXSParClassification[sxsdir_,ClassStr_]. Given a list of SXS NR. data folders 'sxsdir', it returns all the cases that match a certain criterion 'ClassStr' (MassRatio range, Precessing or not, Initial Distance, Orbits Number)taking as reference the SXS metadata.txt files. If it is used iteratively, one could do different classifications ";
SphericalHarmonic::usage="SphericalHarmonic[s_,l_,m_]";
TakeColumn::usage="TakeColumn[list1_?ListQ,columns]. Given a list, take the columns specified by 'columns'. ";
ReSampleTD::usage="ReSampleTD[data_,sample_]. Resample your data with step-size 'sample'.";
AtomsList::usage="AtomsList[expr_]. Split your expression in elements";
InterpolationDomain::usage="InterpolationDomain[IntFunction]. Outputs the domain of your interpolated function IntFunction";
positionDuplicates::usage="positionDuplicates[list_]. Finds the duplicate elements in your list";
\[Omega]lmn::usage="\[Omega]lmn[l_,m_,n_,Mf_,af_,ModesData\[Rule]{}]. It computes the lmn frequency and damping time for a BBH with parameters {Mf,af}. ModesData can be feed with a datafile containing the modes data, which it speeds up the computation. An optional SpinWeight (by default -2) can be given. Warning: a negative spin weight - |s| is always assumed for any input SpinWeight s, and m is always replaced by |m|.";
\[Omega]lmnPy::usage="\[Omega]lmnPy[l_,m_,n_,Mf_,af_]. It computes the lmn frequency and damping time for a BBH with parameters {Mf,af} from the python qnm package. An optional SpinWeight (by default -2) can be given, and its sign is accounted for."
\[Omega]22nTable::usage="\[Omega]lmnPy[l_,m_,n_,Mf_,af_]. It computes the lmn frequency and damping time for a BBH with parameters {Mf,af} from the python qnm package. An optional SpinWeight (by default -2) can be given, and its sign is accounted for.";
DetectConvergence::usage="DetectConvergence[dampsignal_,\[Tau]_,OptionsPattern[{Test\[Rule]FindMaximum}]]. Given a damped signal and a damping time, it estimaes a time t0 where the decay is order 1%";
OvertoneModel::usage="OvertoneModelV[overtones_,pars_,ti_,OptionsPattern[]]. It provides a RDown ansatz for the desired number 'overtones' with parameters {Mf,af}.";
FitRingdown::usage="FitRingdown[data_,nmax_,truepars_]";
FitRingdownGrid::usage="FitRingdownGrid[thedata_,nmax_,thetmin_,massrange_,OptionsPattern[]]. Find the best fit parameters on mass and spin by running the code on mesh refined grid";
OvertoneFromReImToComplex::usage="OvertoneFromReImToComplex[{xi}, {xi,yi}]. It converts a {xi,yi} ansatz to an xi ansatz. xi are the variables and {xi, yi} the numeric values";
AICcRes::usage="AICRes[residuals_,coeff_]. It computes the AICc value from the residuals given the number of coefficients 'coeff' ";
BICRes::usage="BICRes[residuals_,coeff_]. It computes the BIC value from the residuals given the number of coefficients 'coeff' ";
PValueTest::usage="PValueTest[residuals_,coeff_]. It computes the P value from the residuals given the number of coefficients 'coeff' ";
CNMinimize::usage="CNMinimize[data_,ansatz_,coeffs_,{x_,xlist_},OptionsPattern[]]. Minimizator for complex data where coeffs are the free coefficients to adjust, x is coordinate variable and x_list its values";
Arg0DStructs::usage="Arg0DStructs[re_,im_] and Arg0DStructs[reim_] computes the phase angle of complex data. the two-argument version is significantly slower, the one-argument version is just a  backwards compatibility interface to UnwrappedPhase.";
Abs0DStructs::usage="Abs0DStructs[re_,im_] computes the absolute value of complex data.";
UnwrapPhaseVector::usage="UnwrapPhaseVector[x_?VectorQ] unwraps the phase of a real vector representing a phase angle.";
UnwrapPhaseMatrix::usage="UnwrapPhaseMatrix[x_?MatrixQ] unwraps the phase of a real time series where the values represent a phase angle.";
UnwrappedPhase::usage="UnwrapPhase[x_?VectorQ] computes the unwrapped phase of a complex vector representing time series values; UnwrapPhase[x_?MatrixQ] computes the unwrapped phase of a complex time series.";
CombineColumns::usage="CombineColumns[list1_,list2_] combines columns from two lists in into a single list, e.g. CombineColumns[{1,2,3},{4,5,6}] will yield {{1,4},{2,5},{3,6}}.";
fH::usage="fH[f,M]";
fNU::usage="fNU[f,M]";
HessianH::usage="HessianH[f_,t_List?VectorQ]. f is the function you want to compute the Hessian and t the list of parameters."
CovarianceMatrix::usage="CovarianceMatrix[res_,vars_,pars_]. It computes the convarianc:e matrix from the residuals and the list of parameters."
CovarianceMatrixFromLikelihood::usage="CovarianceMatrixFromLikelihood[data_]. It computes the convariance matrix from the likelihood distribution and the list of parameters."
CorrelationMatrix::usage="CovarianceMatrix[res_,vars_,pars]. It computes the correlation matrix from the residuals and the list of parameters."
FisherMatrix::usage="FisherMatrix[f_,par_List?VectorQ,truepars_List?VectorQ,OptionsPattern[]]";
LogLikelihoodDist::usage="Likelihood[data_,ansatz_,vars_,x_]. It computes the likelihood."
ComputeFitBands::usage="ComputeFitBands[data_,ansatz_,vars_,pars_,ConfidenceLevel\[Rule]val]. It computes the fit ConfidentBands at the val confidence level."
SXSWaveMass::usage="SXSWaveMass[data_]";
SXSWaveSpin::usage="SXSWaveSpin[data_,initialJ_,mymodes_]";

tPhys::usage="tPhys[t,M]";
tNR::usage="tNR[t,M]";


Begin["`Private`"]


Options[EasyMatchT]={PadRight->7, Listable->True, FreqFormat->{"Mf","Index","Index"},DisableChecks->False};
Options[EasyMatchT]=Options[EasyMatchT];
EasyMatchT[h1_?ListQ,h2_?ListQ,tMin_,tMax_,OptionsPattern[]]:=Module[{t,fHz,scale,h1red,h2red,tableS,norm1,norm2,myTable,myTable2,prod,psddat,fMinInd,fMaxInd,dt},

h1red=Select[h1,tMin<=#[[1]]<=tMax&][[All,2]];
h2red=Select[h2,tMin<=#[[1]]<=tMax&][[All,2]];

norm1=Total[(Abs@h1red)^2];
norm2=Total[(Abs@h2red)^2];

myTable=h1red Conjugate@h2red;
Re@Total[myTable]/Sqrt[norm1 norm2]
];


IsFPNumberQ[str_String]:=StringMatchQ[StringTrim@str,RegularExpression["[+-]?\\d+\\.?\\d*$"]] || 
                         StringMatchQ[StringTrim@str,RegularExpression["[-+]?\\d*\\.\\d+([eE][-+]?\\d+)?"]]


TimeOfMaximum[list_?ListQ,OptionsPattern[{"MinTime"->""}]]:=Module[{reducedList,vals,maxval,maxpos,mintime},

mintime=OptionValue["MinTime"];

If[NumberQ@mintime,
 reducedList=Select[list,#[[1]]>= mintime&];,
 reducedList=list;
];

vals=Abs@TakeColumn[reducedList,2];
maxval=Max@vals;

If[Length@Union@vals>1,
maxpos=First@First@Position[vals,maxval];
First[reducedList[[maxpos]]],
"NOMAX"]
];


PlanckTaper[t_?VectorQ,t1_,t2_]:=Module[{tmid=Select[t,t1<#<t2&]},Join[
ConstantArray[0,Length@Select[t,#<=t1&]],
1/(Exp[(t2-t1)/(tmid-t1)+(t2-t1)/(tmid-t2)]+1),
ConstantArray[1,Length@Select[t,#>=t2&]]
]];
PlanckTaper[t_?NumberQ,t1_,t2_]:=
Piecewise[{{0,t<=t1},
{1/(Exp[(t2-t1)/(t-t1)+(t2-t1)/(t-t2)]+1),t1<t<t2},
{1,t>= t2}
}];


StringToNumber[y_]:=Module[{temp,x},

x = ToString@y;

temp = StringReplace[x," "->""];

If[StringMatchQ[temp,NumberString],
  ToExpression@temp,
  temp = ReadFloatingPointNumbers[temp]; 
  If[ListQ@temp && Length@temp > 0,
    First@temp,
    Indeterminate
  ]]
]


ReadFloatingPointNumbers[lineIn_String,matchAnyFP_:True]:=Module[{line,fpregex,simpleHackRule,temp},
temp=Map[ToString,Range[0,9]];

simpleHackRule=temp/.xx_/;StringQ@xx:>xx->xx<>".0";
line=lineIn/.simpleHackRule;

simpleHackRule=temp/.xx_/;StringQ@xx:>xx<>"."->xx<>".0";
line=line/.simpleHackRule;

If[matchAnyFP,fpregex="[-+]?\\d*\\.\\d+([eE][-+]?\\d+)?";(*matches any floating point number*),fpregex="[-+]?\\d*\\.?\\d+[eE][-+]?\\d+";(*matches only floating point numbers in exponential format*)];
Map[Read[StringToStream[#],Number]&,StringCases[line,RegularExpression[fpregex]]]
];


ReSampleTD[data_,sample_]:=Module[{dataInt,domain,times},

dataInt=Interpolation@data;
domain=InterpolationDomain@dataInt;
times=Range[domain[[1,1]],domain[[1,2]],sample];
Transpose[{times,dataInt@times}]
]


(* ::Code::Initialization:: *)
AtomsList[expr_]:=Union@Select[Level[expr,{0,Infinity}],AtomQ];
InterpolationDomain[fun_]:=Module[{min,max},fun[[1]]];
TakeColumn[list1_?ListQ,list2_?ListQ]:=Map[Part[#,list2]&,list1];
TakeColumn[list1_?ListQ,n_?IntegerQ]:=(list1//Transpose)[[n]];


positionDuplicates[listaux_]:=GatherBy[Range@Length[listaux],listaux[[#]]&];


Arg0DStructs[reim_?MatrixQ]:=UnwrappedPhase[reim]


Arg0DStructs[reim_?MatrixQ,thresh_?NumberQ]:=Arg0DStructs[reim]


Arg0DStructs[re_?MatrixQ,im_?MatrixQ]:=Module[{revals,imvals,reim,reimvals,times,i,j,diff,
tmp,twopi,zero,test,thresh=N@\[Pi]},

times=TakeColumn[re,1];
revals=TakeColumn[re,2];
imvals=TakeColumn[im,2];
reim = revals + I imvals;

reimvals=Arg@TakeColumn[reim,2];

tmp=N[2 \[Pi]];
twopi=ConstantArray[tmp,Length@times];
zero=ConstantArray[0.,Length@times];

Do[
test=(reimvals[[i+1]]-reimvals[[i]]);
If[(test>thresh),
reimvals=reimvals-Join[zero[[;;i]],twopi[[i+1;;]]];
];

If[(test<-thresh),
reimvals=reimvals+Join[zero[[;;i]],twopi[[i+1;;]]];
];,
{i,1,Length@reimvals-1}
];
CombineColumns[times,reimvals]
];


Abs0DStructs[re_,im_]:=Module[{revals,imvals,reimvals,times,dt,result},

times=Map[First,re];
revals=Map[Last,re];
imvals=Map[Last,im];

reimvals=revals + I imvals;
reimvals=Abs@reimvals;

result=CombineColumns[times,reimvals]
];


Abs0DStructs[reim_]:=Module[{reimvals,times,dt,result},

times=Map[First,reim];

reimvals=Map[Last,reim];
reimvals=Abs@reimvals;

result=CombineColumns[times,reimvals]
];


UnwrapPhaseVector=Compile[{{data,_Real,1}},
(* Juergen Tischer,
http://forums.wolfram.com/mathgroup/archive/1998/May/msg00105.html*)
FoldList[Round[(#1-#2)/(2Pi)] 2Pi+#2&,First[data],Rest[data]]
];


UnwrappedPhase[data_?VectorQ]:=UnwrapPhaseVector[Arg@data]


UnwrappedPhase[data_?MatrixQ]:=CombineColumns[TakeColumn[data,1],UnwrapPhaseVector[Arg@TakeColumn[data,2]]]


CombineColumns[list1_,list2_]:=If[Length@list1==Length@list2, {list1,list2}//Transpose,0{list1,list1}//Transpose]

CombineColumns[list_]:=If[Length@Union@(Length /@ list) == 1, list//Transpose,{}]


fH[f_,M_]:=Module[{c,G,MS},
c=2.99792458 10^8;G=6.67259*10^-11;MS=1.9885*10^30;
(c)^3/((M)MS(G)) f];(* in Solar mass units *)
fNU[f_,M_]:=Module[{c,G,MS},c=2.99792458 10^8;G=6.67259*10^-11;MS=1.9885*10^30;((M)MS(G))/(c)^3 f]

tPhys[t_,M_]:=Module[{c,G,MS},c=2.99792458 10^8;G=6.67259*10^-11;MS=1.9885*10^30;
                     ((M)MS(G))/(c)^3 t]

tNR[t_,M_]:=Module[{c,G,MS},c=2.99792458 10^8;G=6.67259*10^-11;MS=1.9885*10^30;
                      1/(((M)MS(G))/(c)^3) t]


Options[CNMinimize]=Join[Options@NMinimize,{"Bounds"->{},"Weights"->{}}];
CNMinimize[data_,ansatz_,vars_,{x_,xlist_},OptionsPattern[]]:=Module[{accgoal,ansatzlist,bounds,likelihood,maxit,method,precgoal,weights},
method=OptionValue["Method"];
maxit=OptionValue["MaxIterations"];
bounds=OptionValue["Bounds"];
accgoal=OptionValue["AccuracyGoal"];
precgoal=OptionValue["PrecisionGoal"];
weights=OptionValue["Weights"];

ansatzlist=ansatz/.x->xlist;
If[Length@weights>0,
	likelihood={Total[(Re[ansatzlist-data]^2+Im[ansatzlist-data]^2)/(2 weights)]},
	likelihood={Total[(Re[ansatzlist-data]^2+Im[ansatzlist-data]^2)]}
	];
	
likelihood=Join[likelihood,bounds];
NMinimize[likelihood,vars,Method->method,MaxIterations->maxit,AccuracyGoal->accgoal,PrecisionGoal->accgoal]
];


GetAsymptoticMultiMode[h5file_,order_,list_,OptionsPattern[{"Verbose"->False,"TiReIm"->True,"ZeroAlign"->False,"ReSample"->True,"Sampling"->0.5,"Code"->"SXS"}]]:=Module[{datasets,code,targetstring,pos,VPrint,
l,m,positions,timreim,tt,re,im,import,zeroalign,tmax,resample,wave,sampling,targetstringt,ritrhs,ritrhsphsi,ritrhsampsi,importa},
VPrint[expr___]:=If[OptionValue["Verbose"],Print[expr]];
timreim=OptionValue["TiReIm"];
zeroalign=OptionValue["ZeroAlign"];
resample=OptionValue["ReSample"];
sampling=OptionValue["Sampling"];
code=OptionValue["Code"];
                                                        
datasets=Import[h5file,"Datasets"];

positions=Flatten@Table[
                 If[NumberQ[order],l=list[[i,1]];
                  m=list[[i,2]];
                  If[code=="SXS",
                  targetstring="/Extrapolated_N"<>ToString[order]<>".dir/Y_l"<>ToString[l]<>"_m"<>ToString[m]<>".dat";,
                  targetstring={"/amp_l"<>ToString[l]<>"_m"<>ToString[m]<>"/X","/amp_l"<>ToString[l]<>"_m"<>ToString[m]<>"/Y","/phase_l"<>ToString[l]<>"_m"<>ToString[m]<>"/X","/phase_l"<>ToString[l]<>"_m"<>ToString[m]<>"/Y"};
                  ]
                      ,
                  If[order==="outermost",targetstring="/OutermostExtraction.dir/Y_l"<>ToString[l]<>"_m"<>ToString[m]<>".dat";]
                 ];
VPrint["Targeting entry: ",targetstring];
If[code=="SXS",
pos=Flatten[Position[datasets,targetstring]],
pos=Flatten[Position[datasets,#]&/@targetstring];
];
pos,{i,1,Length[list]}];

If[code=="SXS",
import=Import[h5file,{"Data",positions}];
,
importa=Import[h5file,{"Data",positions}];
                import=Table[
				ritrhsampsi=Interpolation[Transpose[importa[[-3+ 4 j;;-3+ 4 j+1]]]];
				ritrhsphsi=Interpolation[Transpose[importa[[-3+ 4 j+2;;-3+ 4 j+3]]]];
				Table[{t,ritrhsampsi[t]Exp[-I ritrhsphsi[t]]},{t,importa[[1,1]],importa[[1,-1]],0.1}],{j,Length@list}];
				If[Length@list==1,import=import[[1]];]
];

If[Length@list==1,import={import};];
If[timreim,wave=(#1/. {tt_,re_,im_}->{tt,re+I im}&)/@import;,wave=import;];
If[resample,wave=ReSampleTD[#,sampling]&/@wave;];
If[zeroalign,tmax=TimeOfMaximum[wave[[1,-Round[(Length@wave[[1]])/2];;-1]]];Table[wave[[i,All,1]]=wave[[i,All,1]]-tmax,{i,Length@import}]];
wave
]


SXSMetaFilesToRules[filePath_]:=Module[{filepath,fileList,meta1,pos1,meta2,meta3,meta4,value,var,list},


If[ListQ@filePath,filepath=filePath[[1]],filepath=filePath];
If[Not@FileExistsQ@filepath,Print["File not found"];Return[]];

(*Reading the file*)
fileList=ReadList[filepath,String];
(*Delete comments*)

meta1=Delete[fileList,Position[StringMatchQ[fileList,"#*"],True]];

(*Fix eccentricity*)
meta1[[Flatten@Position[StringMatchQ[meta1,"*<*e-*"],True]]]=StringReplace[meta1[[Flatten@Position[StringMatchQ[meta1,"*<*e-*"],True]]],"<"->""];

(*Find = *)
meta2=meta1[[Flatten@Position[StringMatchQ[meta1,"*=*"],True]]];

meta3=StringSplit[meta2,"="];

(* Select non-empty fields*)
meta3=Select[meta3,Length@#>1&];

(*Delete spaces*)
meta4=Transpose[{StringReplace[meta3[[All,1]]," "->""],StringReplace[meta3[[All,2]]," "->""]}];

var=meta4[[All,1]];
value=meta4[[All,2]];

value=StringSplit[#,","]&/@value;
(*Delete empty elements*)
(*value=Select[value, UnsameQ[#, {}] &];*)

list={};
Do[
If[Length@value[[i]]==0,
      {}
     ,
      If[IsFPNumberQ@value[[i,1]],
	  value[[i]]=(StringToNumber@#)&/@value[[i]];
        ];
      list=AppendTo[list,{var[[i]]->value[[i]]}];
     ];
,
{i,1,Length@value}];

Flatten@list

]


SXSParClassification[sxsdir_?ListQ,ClassStr_?ListQ,OptionsPattern[{"\[Epsilon]"->0.001,"HighSpin"->0.8,"UnRepeated"->False,"Verbose"->False,
"Mass1-Str"->"initial_mass1","Mass2-Str"->"initial_mass2","MetadataType"->"json","CBCType"->"BHBH","Final-Spin"->"remnant-dimensionless-spin"}]]:=Module[{metafiles,metadata,orbitStr="number-of-orbits",dStr="initial-separation",mass1Str,mass2Str,spin1Str="reference_dimensionless_spin1",
spin2Str="reference_dimensionless_spin2",finalspinStr="remnant_dimensionless_spin",eccStr="reference_eccentricity",cbc,cbctype,cbctypestr="object_types",spin1Dim,spin2Dim,mass1,mass2,massratio,meta,finalspin,eccentricity,dist,orbit,select,pos,condition,A1,A2,precvalue,precvalueNorm,\[Epsilon],
spin1Norm,spin2Norm,highspin,spintest,\[Chi]eff,sxsdirout,spinz,spinzDiff,auxDist,posdup,posdupDist,posdistecc,unrepeated,verbose,sxsdiroutaux,precvalue1,precvalue2,precvalueNorm1,precvalueNorm2},

Print["Classification Input Variables. Examples: {{'MassRatio', '0.99<#<1.1'}},{{'Distance', '#>16'}},{{'Orbits', '#>25'}},{{'Precessing'}},
{{'CBCType','BHBH'},{'Non-Precessing'}},{{'High-Spin'}},{{'\[Chi]eff','#>0.6'}},{{'\[Chi]1','#>0.6'}},{{'\[Chi]2','#>0.6'}},{{'Unequal'}}"];
Print["Take care! Some of the sxs file names are not consistent with the metadata files"];
Print["The spin definition is consitent with 'initial-spin' values and not relaxed ones"];
Print["The mass definition is consitent with 'initial-mass' values and not relaxed ones"];

mass1Str=OptionValue["Mass1-Str"];
mass2Str=OptionValue["Mass2-Str"];
meta = OptionValue["MetadataType"];
cbctype = OptionValue["CBCType"];

(* Kill the loop if the root directory is wrong *)
If[And@@(Not/@DirectoryQ/@sxsdir),Print[Style["Directory not found",Red]];Return[{}]];

sxsdirout=sxsdir;

\[Epsilon]=OptionValue["\[Epsilon]"];
highspin=OptionValue["HighSpin"];
unrepeated=OptionValue["UnRepeated"];
verbose=OptionValue["Verbose"];

Which[meta=="txt",
metafiles=Flatten[FileNames["metadata.txt",#,4]&/@sxsdirout,1];
metadata=SXSMetaFilesToRules[#]&/@metafiles;,
meta=="json", metafiles=Flatten[FileNames["metadata.json",#,4]&/@sxsdirout,1]; metadata=Import/@metafiles];

cbc=Flatten@((cbctypestr/.#)&/@metadata);
pos=Flatten@Position[cbc,_?(#==cbctype&)];
metadata=metadata[[pos]];
cbc=cbc[[pos]];

mass1=Flatten@((mass1Str/.#)&/@metadata);
mass2=Flatten@((mass2Str/.#)&/@metadata);
finalspin=((finalspinStr/.#)&/@metadata)[[All,-1]];
massratio=mass1/mass2;
dist=Flatten@((dStr/.#)&/@metadata);
orbit=Flatten@((orbitStr/.#)&/@metadata);
spin1Dim=((spin1Str/.#)&/@metadata);
spin2Dim=((spin2Str/.#)&/@metadata);
A1=(1+3 massratio/(4.));
A2=(1+3 /(4.*massratio) );
\[Chi]eff=massratio/(1.+massratio)*spin1Dim +1./(1+massratio)*spin2Dim;

eccentricity=StringReplace[ToString/@(Flatten[(eccStr/.#)&/@metadata]),{"<"->"","NaN"->"0"}];
eccentricity=ToExpression/@StringReplace[eccentricity, {"e+" :> "*^", "e-" :> "*^-"}];

spinz=Chop/@Transpose[{TakeColumn[spin1Dim,3],TakeColumn[spin2Dim,3]}];
spinzDiff=Abs[(#[[2]]-#[[1]])&/@spinz];
condition=ClassStr[[All,1]];
select=Table[If[Length@ClassStr[[i]]==2,ToExpression@(ClassStr[[i,2]]),"Null"],{i,1,Length@ClassStr}];
pos=Table[i,{i,Length@sxsdirout}];

Do[

Which[condition[[i]]=="CBCType",
Null;
,condition[[i]]=="MassRatio",

If[Length@ClassStr[[i]]!= 2,Print["Wrong input"];Break[]];

pos=Flatten@Position[massratio,_?(Evaluate[select[[i]]]&)];
massratio=massratio[[pos]];
dist=dist[[pos]];
orbit=orbit[[pos]];
spin1Dim=spin1Dim[[pos]];
spin2Dim=spin2Dim[[pos]];
A1=A1[[pos]];
A2=A2[[pos]];
spinzDiff=spinzDiff[[pos]];
eccentricity=eccentricity[[pos]];
\[Chi]eff=\[Chi]eff[[pos]];
finalspin=finalspin[[pos]];
sxsdirout=sxsdirout[[pos]];,

condition[[i]]=="Final-Spin",

If[Length@ClassStr[[i]]!= 2,Print["Wrong input"];Break[]];

pos=Flatten@Position[finalspin,_?(Evaluate[select[[i]]]&)];

massratio=massratio[[pos]];
dist=dist[[pos]];
orbit=orbit[[pos]];
spin1Dim=spin1Dim[[pos]];
spin2Dim=spin2Dim[[pos]];
A1=A1[[pos]];
A2=A2[[pos]];
spinzDiff=spinzDiff[[pos]];
eccentricity=eccentricity[[pos]];
\[Chi]eff=\[Chi]eff[[pos]];
finalspin=finalspin[[pos]];

sxsdirout=sxsdirout[[pos]];,

condition[[i]]== "Distance",

If[Length@ClassStr[[i]]!= 2,Print["Wrong input"];Break[]];

pos=Flatten@Position[sxsdirout=sxsdirout[[pos]];,_?(Evaluate[select[[i]]]&)];
massratio=massratio[[pos]];
dist=dist[[pos]];
orbit=orbit[[pos]];
spin1Dim=spin1Dim[[pos]];
spin2Dim=spin2Dim[[pos]];
A1=A1[[pos]];
A2=A2[[pos]];
spinzDiff=spinzDiff[[pos]];
eccentricity=eccentricity[[pos]];
\[Chi]eff=\[Chi]eff[[pos]];
finalspin=finalspin[[pos]];
sxsdirout=sxsdirout[[pos]];,

condition[[i]]== "Orbits",

If[Length@ClassStr[[i]]!= 2,Print["Wrong input"];Break[]];

pos=Flatten@Position[orbit,_?(Evaluate[select[[i]]]&)];
massratio=massratio[[pos]];
dist=dist[[pos]];
orbit=orbit[[pos]];
spin1Dim=spin1Dim[[pos]];
spin2Dim=spin2Dim[[pos]];
A1=A1[[pos]];
A2=A2[[pos]];
spinzDiff=spinzDiff[[pos]];
eccentricity=eccentricity[[pos]];
\[Chi]eff=\[Chi]eff[[pos]];
finalspin=finalspin[[pos]];
sxsdirout=sxsdirout[[pos]];,

condition[[i]]== "Non-Precessing",

(*precvalue=(#)\[Cross]{0,0,1}&/@((spin1Dim)A1+(spin2Dim)A2);*)
precvalue1=(#)\[Cross]{0,0,1}&/@((spin1Dim)A1);
precvalue2=(#)\[Cross]{0,0,1}&/@((spin2Dim)A2);
precvalueNorm1=Norm[#]&/@precvalue1;
precvalueNorm2=Norm[#]&/@precvalue2;
precvalueNorm=precvalueNorm1^2+precvalueNorm2^2;
pos=Flatten@Position[precvalueNorm,_?(#<\[Epsilon] &)];

massratio=massratio[[pos]];
dist=dist[[pos]];
orbit=orbit[[pos]];
spin1Dim=spin1Dim[[pos]];
spin2Dim=spin2Dim[[pos]];
A1=A1[[pos]];
A2=A2[[pos]];
spinzDiff=spinzDiff[[pos]];
eccentricity=eccentricity[[pos]];
\[Chi]eff=\[Chi]eff[[pos]];
finalspin=finalspin[[pos]];
sxsdirout=sxsdirout[[pos]];,

condition[[i]]== "Unequal",

pos=Flatten@Position[spinzDiff,_?(#>\[Epsilon] &)];

massratio=massratio[[pos]];
dist=dist[[pos]];
orbit=orbit[[pos]];
spin1Dim=spin1Dim[[pos]];
spin2Dim=spin2Dim[[pos]];
A1=A1[[pos]];
A2=A2[[pos]];
spinzDiff=spinzDiff[[pos]];
eccentricity=eccentricity[[pos]];
\[Chi]eff=\[Chi]eff[[pos]];
finalspin=finalspin[[pos]];
sxsdirout=sxsdirout[[pos]];,

condition[[i]]=="Precessing",

precvalue1=(#)\[Cross]{0,0,1}&/@((spin1Dim)A1);
precvalue2=(#)\[Cross]{0,0,1}&/@((spin2Dim)A2);
precvalueNorm1=Norm[#]&/@precvalue1;
precvalueNorm2=Norm[#]&/@precvalue2;
precvalueNorm=precvalueNorm1^2+precvalueNorm2^2;

(*precvalue=(#)\[Cross]{0,0,1}&/@((spin1Dim)A1+(spin2Dim)A2);*)

pos=Flatten@Position[precvalueNorm,_?(#>\[Epsilon] &)];
massratio=massratio[[pos]];
dist=dist[[pos]];
orbit=orbit[[pos]];
spin1Dim=spin1Dim[[pos]];
spin2Dim=spin2Dim[[pos]];
A1=A1[[pos]];
A2=A2[[pos]];
spinzDiff=spinzDiff[[pos]];
eccentricity=eccentricity[[pos]];
\[Chi]eff=\[Chi]eff[[pos]];
finalspin=finalspin[[pos]];
sxsdirout=sxsdirout[[pos]];,

condition[[i]]== "High-Spin",

spin1Norm=Norm[#]&/@spin1Dim;
spin2Norm=Norm[#]&/@spin2Dim;

spintest=Table[If[Abs@spin1Norm[[i]]>=highspin || Abs@spin2Norm[[i]]>=highspin,True,False],{i,1,Length@spin1Norm}];
pos=Flatten@Position[spintest,True];
massratio=massratio[[pos]];
dist=dist[[pos]];
orbit=orbit[[pos]];
spin1Dim=spin1Dim[[pos]];
spin2Dim=spin2Dim[[pos]];
A1=A1[[pos]];
A2=A2[[pos]];
spinzDiff=spinzDiff[[pos]];
eccentricity=eccentricity[[pos]];
\[Chi]eff=\[Chi]eff[[pos]];
finalspin=finalspin[[pos]];
sxsdirout=sxsdirout[[pos]];,

condition[[i]]== "\[Chi]eff",

If[Length@ClassStr[[i]]!= 2,Print["Wrong input"];Break[]];

pos=Flatten@Position[Norm[#]&/@\[Chi]eff,_?(Evaluate[select[[i]]] &)];
massratio=massratio[[pos]];
dist=dist[[pos]];
orbit=orbit[[pos]];
spin1Dim=spin1Dim[[pos]];
spin2Dim=spin2Dim[[pos]];
A1=A1[[pos]];
A2=A2[[pos]];
spinzDiff=spinzDiff[[pos]];
eccentricity=eccentricity[[pos]];
\[Chi]eff=\[Chi]eff[[pos]];
finalspin=finalspin[[pos]];
sxsdirout=sxsdirout[[pos]];,

condition[[i]]== "\[Chi]1",

If[Length@ClassStr[[i]]!= 2,Print["Wrong input"];Break[]];

pos=Flatten@Position[Norm[#]&/@spin1Dim,_?(Evaluate[select[[i]]] &)];
massratio=massratio[[pos]];
dist=dist[[pos]];
orbit=orbit[[pos]];
spin1Dim=spin1Dim[[pos]];
spin2Dim=spin2Dim[[pos]];
A1=A1[[pos]];
A2=A2[[pos]];
spinzDiff=spinzDiff[[pos]];
eccentricity=eccentricity[[pos]];
\[Chi]eff=\[Chi]eff[[pos]];
finalspin=finalspin[[pos]];
sxsdirout=sxsdirout[[pos]];,

condition[[i]]== "\[Chi]2",

If[Length@ClassStr[[i]]!= 2,Print["Wrong input"];Break[]];

pos=Flatten@Position[Norm[#]&/@spin2Dim,_?(Evaluate[select[[i]]] &)];
massratio=massratio[[pos]];
dist=dist[[pos]];
orbit=orbit[[pos]];
spin1Dim=spin1Dim[[pos]];
spin2Dim=spin2Dim[[pos]];
A1=A1[[pos]];
A2=A2[[pos]];
spinzDiff=spinzDiff[[pos]];
eccentricity=eccentricity[[pos]];
\[Chi]eff=\[Chi]eff[[pos]];
finalspin=finalspin[[pos]];
sxsdirout=sxsdirout[[pos]];,


condition[[i]]== "relaxed-eccentricity",

If[Length@ClassStr[[i]]!= 2,Print["Wrong input"];Break[]];

pos=Flatten@Position[eccentricity,_?(Evaluate[select[[i]]] &)];
massratio=massratio[[pos]];
dist=dist[[pos]];
orbit=orbit[[pos]];
spin1Dim=spin1Dim[[pos]];
spin2Dim=spin2Dim[[pos]];
A1=A1[[pos]];
A2=A2[[pos]];
spinzDiff=spinzDiff[[pos]];
eccentricity=eccentricity[[pos]];
\[Chi]eff=\[Chi]eff[[pos]];
finalspin=finalspin[[pos]];
sxsdirout=sxsdirout[[pos]];,
 True,
Print[Style["Wrong input",Bold,Red,16]];
Break[];
];
,{i,1,Length@ClassStr}];


If[unrepeated,

Print["Taking among the repeated cases only those with lower eccentricity and larger D (just in case ei=ej)"];

(* Selecting Case with lower e *)
auxDist=Transpose[{Round[#&/@massratio,0.1],Round[Chop[#,10^(-2)],0.01]&/@spin1Dim,Round[Chop[#,10^(-2)],0.01]&/@spin2Dim,dist,eccentricity}];
posdup=positionDuplicates@auxDist[[All,1;;3]];
posdistecc=Flatten[#,1]&/@Table[Position[auxDist[[posdup[[i]],5]],Min@auxDist[[posdup[[i]],5]]],{i,1,Length@posdup}];
posdistecc=Flatten@Table[posdup[[i,posdistecc[[i]]]],{i,1,Length@posdup}];
sxsdirout=sxsdirout[[posdistecc]];

(* Selecting Case with larger D *)
auxDist=auxDist[[posdistecc]];
posdup=positionDuplicates@auxDist[[All,1;;3]];
posdistecc=Flatten[#,1]&/@Table[Position[auxDist[[posdup[[i]],4]],Max@auxDist[[posdup[[i]],4]]],{i,1,Length@posdup}];
posdistecc=Flatten@Table[posdup[[i,posdistecc[[i]]]],{i,1,Length@posdup}];

auxDist=auxDist[[posdistecc]];
sxsdirout=sxsdirout[[posdistecc]];
sxsdiroutaux=SortBy[Table[Join[{sxsdirout[[i]]},auxDist[[i]]],{i,1,Length@sxsdirout}],#[[2]]&];

If[verbose, 
Print[Prepend[Table[ToString@#&/@sxsdiroutaux[[i]],{i,1,Length@sxsdiroutaux}],{"Case","q","\[Chi]1","\[Chi]2","D","e"}]//TableForm]];

sxsdiroutaux[[All,1]],

auxDist=Transpose[{Round[#&/@massratio,0.1],Round[Chop[#,10^(-2)],0.01]&/@spin1Dim,Round[Chop[#,10^(-2)],0.01]&/@spin2Dim,dist,eccentricity}];
(*sxsdiroutaux=Table[Join[{sxsdirout[[i]]},auxDist[[i]]],{i,1,Length@sxsdirout}];*)
sxsdiroutaux=SortBy[Table[Join[{sxsdirout[[i]]},auxDist[[i]]],{i,1,Length@sxsdirout}],#[[2]]&];
If[verbose, 
Print[Prepend[Table[ToString@#&/@sxsdiroutaux[[i]],{i,1,Length@sxsdiroutaux}],{"Case","q","\[Chi]1","\[Chi]2","D","e"}]//TableForm]];

sxsdiroutaux[[All,1]]]
]


Options[\[Omega]lmn]={"ModesData"->{},"ModesFile"->"","SpinWeight"->-2,"CounterRotating"->False,"Interpolate\[Omega]\[Tau]"->False,"MaxSpin"->0.99,"w228data"->{},"w229data"->{},"wc228data"->{},"wlmntables"->{},"Mixing"->{False,{2,2}},"wlmnmixtables"->{},"wlmnctables"->{}};
\[Omega]lmn[l_,m_,n_,Mf_,af_,OptionsPattern[]]:=Module[{counterrotating,file,data,modesdata,modesfile,mstr,sp,spinweight,fmass,f\[Chi],\[Chi]\[Omega]\[Tau],\[Omega],\[Tau],llim,ulim,wlmntables},
modesdata=OptionValue["ModesData"];
modesfile=OptionValue["ModesFile"];
spinweight=Abs[OptionValue["SpinWeight"]];
counterrotating=OptionValue["CounterRotating"];

If[Length[modesdata]==0,
    If[m>=0,mstr="m",mstr="mm"];
    file=modesfile<>"s"<>ToString[spinweight]<>"/l"<>ToString[l]<>"/n"<>ToString[n+1]<>"l"<>ToString[l]<>mstr<>ToString[Abs[m]]<>".dat";
    If[Not@FileExistsQ[file],Print["File not found"];Return[];];
    data=Import[file];,
       
    data=modesdata;
       ];

\[Chi]\[Omega]\[Tau]=TakeColumn[data,{1,2,3}];

fmass=Mf;
f\[Chi]=af;

If[af>0,
   (* Take the neighbour points and interpolate them *)
   ulim=Flatten[Select[\[Chi]\[Omega]\[Tau],#[[1]]>=f\[Chi]&,1]];
   llim=Flatten[Select[\[Chi]\[Omega]\[Tau],#[[1]]-ulim[[1]]<0&][[-1]]];
   \[Omega]=Mean[Join[{ulim},{llim}]][[2]]/fmass;
   \[Tau]=Mean[(Abs[1/Join[{ulim[[-1]]},{llim[[-1]]}]]*fmass)];,
   
   ulim=Flatten[Select[\[Chi]\[Omega]\[Tau],#[[1]]>=f\[Chi]&,1]];
   \[Omega]=ulim[[2]]/fmass;
   \[Tau]=Abs[1/ulim[[-1]]]*fmass;
];
If[counterrotating,\[Omega]=-\[Omega]];
{\[Omega],\[Tau]}
]


Options[\[Omega]lmnPy]=Options[\[Omega]lmn];
\[Omega]lmnPy[l_,m_,n_,Mf_,af_,OptionsPattern[]]:=Module[{w228data,w229data,wc228data,counterrotating,file,fmass,data,Global`a,intws,maxspin,mixing,modesdata,modesfile,mstr,sp,spinweight,f\[Chi],\[Chi]\[Omega]\[Tau],\[Omega],\[Omega]1,\[Omega]s,\[Omega]stab,\[Tau],\[Tau]1,llim,ulim,xx,yy,zz},
modesdata=OptionValue["ModesData"];
modesfile=OptionValue["ModesFile"];
spinweight=OptionValue["SpinWeight"];
counterrotating=OptionValue["CounterRotating"];
intws=OptionValue["Interpolate\[Omega]\[Tau]"];
maxspin =OptionValue["MaxSpin"];
w228data = OptionValue["w228data"];
wc228data = OptionValue["wc228data"];
w229data = OptionValue["w229data"];
mixing=OptionValue["Mixing"];

If[intws,

Which[l==2 && m==2 &&n==8,
If[counterrotating,
\[Omega]s=Conjugate[TakeColumn[wc228data,{1,2,3}]/.{xx_,yy_,zz_}->{xx,-(yy+I zz) }];,
\[Omega]s=TakeColumn[w228data,{1,2,3}]/.{xx_,yy_,zz_}->{xx,yy+I zz };
];
,l==2 && m==2 &&n==9,
If[counterrotating,
\[Omega]s=Conjugate[Table[{a,-ExternalEvaluate[Global`session, "omegas=[];grav_220=qnm.modes_cache(s="<>ToString[spinweight]<>",l="<>ToString[l]<>",m="<>ToString[-m]<>",n=" <> ToString[n] <> ");(grav_220(a="<>ToString[DecimalForm[a]]<>"))[0]"]},{a,0,0.99,0.01}]];,
\[Omega]s=TakeColumn[w229data,{1,2,3}]/.{xx_,yy_,zz_}->{xx,yy+I zz };
];
,l==2 && m==2 &&(n>9) ,
If[counterrotating,
\[Omega]s=Conjugate[Table[{a,-ExternalEvaluate[Global`session, "omegas=[];grav_220=qnm.modes_cache(s="<>ToString[spinweight]<>",l="<>ToString[l]<>",m="<>ToString[-m]<>",n=" <> ToString[n] <> ");(grav_220(a="<>ToString[DecimalForm[a]]<>"))[0]"]},{a,0,0.99,0.01}]];,
\[Omega]s=Table[{a,ExternalEvaluate[Global`session, "omegas=[];grav_220=qnm.modes_cache(s="<>ToString[spinweight]<>",l="<>ToString[l]<>",m="<>ToString[Abs@m]<>",n=" <> ToString[n-1] <> ");(grav_220(a="<>ToString[DecimalForm[a]]<>"))[0]"]},{a,0,0.99,0.01}];
];
,True,
If[counterrotating,
\[Omega]s=Conjugate@Table[{a,
If[a<0,-ExternalEvaluate[Global`session, "omegas=[];grav_220=qnm.modes_cache(s="<>ToString[spinweight]<>",l="<>ToString[l]<>",m="<>ToString[m]<>",n=" <> ToString[n] <> ");(grav_220(a="<>ToString[DecimalForm[Abs@a]]<>"))[0]"],
-ExternalEvaluate[Global`session, "omegas=[];grav_220=qnm.modes_cache(s="<>ToString[spinweight]<>",l="<>ToString[l]<>",m="<>ToString[-m]<>",n=" <> ToString[n] <> ");(grav_220(a="<>ToString[DecimalForm[a]]<>"))[0]"]]
(*-ExternalEvaluate[Global`session, "omegas=[];grav_220=qnm.modes_cache(s="<>ToString[spinweight]<>",l="<>ToString[l]<>",m="<>ToString[-m]<>",n=" <> ToString[n] <> ");(grav_220(a="<>ToString[DecimalForm[a]]<>"))[0]"]*)},{a,-0.99,0.99,0.01}];,
\[Omega]s=Table[{a,
(*ExternalEvaluate[Global`session, "omegas=[];grav_220=qnm.modes_cache(s="<>ToString[spinweight]<>",l="<>ToString[l]<>",m="<>ToString[Abs@m]<>",n=" <> ToString[n] <> ");(grav_220(a="<>ToString[DecimalForm[a]]<>"))[0]"]*)
If[a<0,ExternalEvaluate[Global`session, "omegas=[];grav_220=qnm.modes_cache(s="<>ToString[spinweight]<>",l="<>ToString[l]<>",m="<>ToString[-m]<>",n=" <> ToString[n] <> ");(grav_220(a="<>ToString[DecimalForm[Abs@a]]<>"))[0]"],
ExternalEvaluate[Global`session, "omegas=[];grav_220=qnm.modes_cache(s="<>ToString[spinweight]<>",l="<>ToString[l]<>",m="<>ToString[Abs@m]<>",n=" <> ToString[n] <> ");(grav_220(a="<>ToString[DecimalForm[a]]<>"))[0]"]]},{a,-0.99,0.99,0.01}];
];
];
\[Omega]1=Re@\[Omega]s;
If[m<0,\[Omega]1=Re@(\[Omega]s/.{xx_,yy_}->{xx,-yy});,\[Omega]1=Re@\[Omega]s;];
Quiet[\[Tau]1=Transpose[{\[Omega]s[[All,1]],-1/Im@\[Omega]s[[All,2]]}]];

\[Omega]=Interpolation@\[Omega]1;
\[Tau]=Interpolation@\[Tau]1;
,
Which[(af == 0 && m == 0), 
\[Omega]s= ExternalEvaluate[Global`session, "omseq = schw(s="<>ToString[spinweight]<>",l="<>ToString[l]<>", n_max=" <> ToString[n] <> "); omseq.find_sequence(); (omseq.omega)[-1]"];
\[Omega]=Re[\[Omega]s]/Mf;
\[Tau]=-1/Im[\[Omega]s]*Mf;

, (l==2 && m==2 &&(n==8)),

If[counterrotating,
\[Omega]s=Conjugate[TakeColumn[wc228data,{1,2,3}]/.{xx_,yy_,zz_}->{xx,-(yy+I zz )}];,
\[Omega]s=TakeColumn[w228data,{1,2,3}]/.{xx_,yy_,zz_}->{xx,yy+ I zz };
];
If[m<0,\[Omega]1=Re@(\[Omega]s/.{xx_,yy_}->{xx,-yy});,\[Omega]1=Re@\[Omega]s;];
Quiet[\[Tau]1=Transpose[{\[Omega]s[[All,1]],-1/Im@\[Omega]s[[All,2]]}]];
\[Omega]=Interpolation@\[Omega]1;
\[Tau]=Interpolation@\[Tau]1;

\[Omega]=Re[\[Omega][af]]/Mf;
\[Tau]=\[Tau][af]*Mf;
,(l==2 && m==2 &&(n==9)),
If[counterrotating,
\[Omega]s=Conjugate[ExternalEvaluate[Global`session, "omegas=[];grav_220=qnm.modes_cache(s="<>ToString[spinweight]<>",l="<>ToString[l]<>",m="<>ToString[-m]<>",n=" <> ToString[n] <> ");(grav_220(a="<>ToString[DecimalForm[af]]<>"))[0]"]];
If[m<0,\[Omega]s=(\[Omega]s/.{xx_,yy_}->{-xx,yy});];
\[Omega]=-Re[\[Omega]s]/Mf;
\[Tau]=1/(Im[\[Omega]s]*Mf);
,
\[Omega]s=TakeColumn[w229data,{1,2,3}]/.{xx_,yy_,zz_}->{xx,yy+ I zz };
If[m<0,\[Omega]1=Re@(\[Omega]s/.{xx_,yy_}->{-xx,-yy});,\[Omega]1=Re@\[Omega]s;];
Quiet[\[Tau]1=Transpose[{\[Omega]s[[All,1]],-1/Im@\[Omega]s[[All,2]]}]];
\[Omega]=Interpolation@\[Omega]1;
\[Tau]=Interpolation@\[Tau]1;

\[Omega]=Re[\[Omega][af]]/Mf;
\[Tau]=\[Tau][af]*Mf;
];
, (l==2 && m==2 &&(n>9)),
If[counterrotating,
\[Omega]s=-Conjugate@ExternalEvaluate[Global`session, "omegas=[];grav_220=qnm.modes_cache(s="<>ToString[spinweight]<>",l="<>ToString[l]<>",m="<>ToString[-m]<>",n=" <> ToString[n] <> ");(grav_220(a="<>ToString[DecimalForm[af]]<>"))[0]"],
\[Omega]s=ExternalEvaluate[Global`session, "omegas=[];grav_220=qnm.modes_cache(s="<>ToString[spinweight]<>",l="<>ToString[l]<>",m="<>ToString[Abs@m]<>",n=" <> ToString[n-1] <> ");(grav_220(a="<>ToString[DecimalForm[af]]<>"))[0]"];];
\[Omega]=Re[\[Omega]s]/Mf;
\[Tau]=-1/Im[\[Omega]s]*Mf;
If[m<0,\[Omega]=-\[Omega]];

, True,
If[counterrotating,
\[Omega]s=-Conjugate@ExternalEvaluate[Global`session, "omegas=[];grav_220=qnm.modes_cache(s="<>ToString[spinweight]<>",l="<>ToString[l]<>",m="<>ToString[-m]<>",n=" <> ToString[n] <> ");(grav_220(a="<>ToString[DecimalForm[af]]<>"))[0]"],
\[Omega]s=ExternalEvaluate[Global`session, "omegas=[];grav_220=qnm.modes_cache(s="<>ToString[spinweight]<>",l="<>ToString[l]<>",m="<>ToString[Abs@m]<>",n=" <> ToString[n] <> ");(grav_220(a="<>ToString[DecimalForm[af]]<>"))[0]"];];
\[Omega]=Re[\[Omega]s]/Mf;
\[Tau]=-1/Im[\[Omega]s]*Mf;
If[m<0,\[Omega]=-\[Omega]];
];

];

{\[Omega],\[Tau]}
]


(* ::Input::Initialization:: *)
Options[\[Omega]22nTable]=Options[\[Omega]lmn];
\[Omega]22nTable[l_,m_,n_,mff_,aff_,OptionsPattern[]]:=Module[{table,tablemix,tablecount,intws,mixing,\[Omega],\[Tau],res},
table=OptionValue["wlmntables"];
tablemix=OptionValue["wlmnmixtables"];
tablecount=OptionValue["wlmnctables"];
intws=OptionValue["Interpolate\[Omega]\[Tau]"];
mixing=OptionValue["Mixing"];

If[Not[mixing[[1]]],
If[Not@intws,
 {\[Omega],\[Tau]}= (#[aff]&/@table[[n+1]])*{1/mff,mff};,
{\[Omega],\[Tau]}= table[[n+1]]];
,
If[Not@intws,
 {\[Omega],\[Tau]}= (#[aff]&/@tablemix[[n+1]])*{1/mff,mff};,
{\[Omega],\[Tau]}= tablemix[[n+1]]];
];
{\[Omega],\[Tau]}
]


EradUIB2017[\[Eta]_,\[Chi]1_,\[Chi]2_]:=Module[{m1,m2,S},
m1=1/2 (1+Sqrt[1-4 \[Eta]]);
m2=1/2 (1-Sqrt[1-4 \[Eta]]);

S= (m1^2 \[Chi]1 + m2^2 \[Chi]2)/(m1^2 + m2^2);

(((1-(2 Sqrt[2])/3) \[Eta]+0.5609904135313374` \[Eta]^2-0.84667563764404` \[Eta]^3+3.145145224278187` \[Eta]^4) (1+S^3 (-0.6320191645391563`+ 4.952698546796005` \[Eta]-10.023747993978121` \[Eta]^2)+S^2 (-0.17762802148331427`+ 2.176667900182948` \[Eta]^2)+S (-0.13084389181783257`- 1.1387311580238488` \[Eta]+5.49074464410971` \[Eta]^2)))/(1+S (-0.9919475346968611`+ 0.367620218664352` \[Eta]+4.274567337924067` \[Eta]^2))
-0.01978238971523653` S (1-4.91667749015812` \[Eta]) (1-4 \[Eta])^0.5` \[Eta] (\[Chi]1-\[Chi]2)-0.09803730445895877` (1-4 \[Eta])^0.5` (1-3.2283713377939134` \[Eta]) \[Eta]^2 (\[Chi]1-\[Chi]2)+0.01118530335431078` \[Eta]^3 (\[Chi]1-\[Chi]2)^2]


FinalSpinUIB2017[\[Eta]_,\[Chi]1_,\[Chi]2_]:=Module[{m1,m2,S},
m1=1/2 (1+Sqrt[1-4 \[Eta]]);
m2=1/2 (1-Sqrt[1-4 \[Eta]]);

S= (m1^2 \[Chi]1 + m2^2 \[Chi]2)/(m1^2 + m2^2);

(m1^2 \[Chi]1 + m2^2 \[Chi]2) +(2 Sqrt[3] \[Eta]+20.0830030082033` \[Eta]^2-12.333573402277912` \[Eta]^3)/(1+7.2388440419467335` \[Eta])+
 0.3223660562764661` (1-4 \[Eta])^0.5` \[Eta]^2 (1+9.332575956437443` \[Eta]) (\[Chi]1-\[Chi]2)-0.059808322561702126` \[Eta]^3 (\[Chi]1-\[Chi]2)^2+
(2.3170397514509933` (1-4 \[Eta])^0.5` (1-3.2624649875884852` \[Eta]) \[Eta]^3 (\[Chi]1-\[Chi]2) (1/4 (1+Sqrt[1-4 \[Eta]])^2 \[Chi]1+1/4 (1-Sqrt[1-4 \[Eta]])^2 \[Chi]2))/(1/4 (1-Sqrt[1-4 \[Eta]])^2+1/4 (1+Sqrt[1-4 \[Eta]])^2)+
(((0.` -0.8561951310209386` \[Eta]-0.09939065676370885` \[Eta]^2+1.668810429851045` \[Eta]^3) (1/4 (1+Sqrt[1-4 \[Eta]])^2 \[Chi]1+1/4 (1-Sqrt[1-4 \[Eta]])^2 \[Chi]2))/(1/4 (1-Sqrt[1-4 \[Eta]])^2+1/4 (1+Sqrt[1-4 \[Eta]])^2)+((0.` +0.5881660363307388` \[Eta]-2.149269067519131` \[Eta]^2+3.4768263932898678` \[Eta]^3) (1/4 (1+Sqrt[1-4 \[Eta]])^2 \[Chi]1+1/4 (1-Sqrt[1-4 \[Eta]])^2 \[Chi]2)^2)/(1/4 (1-Sqrt[1-4 \[Eta]])^2+1/4 (1+Sqrt[1-4 \[Eta]])^2)^2+((0.` +0.142443244743048` \[Eta]-0.9598353840147513` \[Eta]^2+1.9595643107593743` \[Eta]^3) (1/4 (1+Sqrt[1-4 \[Eta]])^2 \[Chi]1+1/4 (1-Sqrt[1-4 \[Eta]])^2 \[Chi]2)^3)/(1/4 (1-Sqrt[1-4 \[Eta]])^2+1/4 (1+Sqrt[1-4 \[Eta]])^2)^3)/(1+((-0.9142232693081653`+ 2.3191363426522633` \[Eta]-9.710576749140989` \[Eta]^3) (1/4 (1+Sqrt[1-4 \[Eta]])^2 \[Chi]1+1/4 (1-Sqrt[1-4 \[Eta]])^2 \[Chi]2))/(1/4 (1-Sqrt[1-4 \[Eta]])^2+1/4 (1+Sqrt[1-4 \[Eta]])^2))]


SXSWaveMass[data_]:=Module[{mymodes,times,sxsmodesInt,sxsmodesIntder,sxsmodesdis,
dedt,metafile,metarules,mass1,mass2,chi1,chi2,d0,amassratio},
If[Length@mymodes==1,data={data}];
times=data[[1,All,1]];
sxsmodesInt=Interpolation/@data;
sxsmodesIntder=Table[Dt[sxsmodesInt[[i]]@t,t]/.y_[t_]->y,{i,Length@data}];
sxsmodesdis=Power[#,2]&/@(Abs/@(#@times&/@sxsmodesIntder));
dedt=Transpose[{times,(times[[2]]-times[[1]])Total[sxsmodesdis]}];

(* First spin position must be the smallest BH . In SXS convenction chi1 spin of the largest BH *)
Total[dedt[[All,2]]]/(8\[Pi])
]


SXSWaveSpin[data_,initialJ_,mymodes_]:=Module[{times,sxsmodesInt,sxsmodesIntder,sxsmodesdis,
dedt,metafile,metarules,mass1,mass2,chi1,chi2,d0,amassratio},

times=data[[1,All,1]];
sxsmodesInt=Table[Interpolation@data[[i]],{i,Length@data}];
sxsmodesIntder=Table[D[sxsmodesInt[[i]][t],t],{i,Length@sxsmodesInt}];
(* The imaginary symbol comes from  Re[I*z] = -Im[z] *)
sxsmodesdis=Sum[mymodes[[n,2]]*sxsmodesInt[[n]][t]*Conjugate[sxsmodesIntder[[n]]],{n,Length@mymodes}];
dedt=(times[[2]]-times[[1]])Im[(sxsmodesdis/.t->times)];


(* First spin position must be the smallest BH . In SXS convenction chi1 spin of the largest BH *)
initialJ-Total[dedt]/(8\[Pi])
]


SphericalHarmonic[s_,l_,m_]:=Block[{res,Global`\[Theta],Global`\[Phi]},
res=Sum[(-1)^i  Sqrt[(l+m)! (l-m)! (l-s)! (l+s)!] / ((l+m-i)!(l+s-i)!i!(i-s-m)!)Cos[Global`\[Theta]/2]^(2l+m+s-2i)Sin[Global`\[Theta]/2]^(2i-s-m),{i,Max[0,m+s],Min[l+m,l+s]}];
res=FullSimplify[(-1)^(-s)  Sqrt[(2l+1)/(4Pi)] res E^(I m Global`\[Phi])];

res]


Options[DetectConvergence]={"Test"->FindMaximum};
DetectConvergence[res_,\[Tau]_,OptionsPattern[]]:=Module[{intres,mins,tmax,t,fits,a,tol,tt,yy,test},

test=OptionValue["Test"];

tmax= 4 * \[Tau];
intres=Interpolation@res;
mins=Quiet[Table[test[intres@t,{t,i}],{i,res[[1,1]]+5,res[[1,1]]+5 +tmax,10}]/.{yy_,tt_}->{t/.tt,yy}];
mins=Select[mins,res[[1,1]]<#[[1]]<res[[-1,1]]&];
SortBy[mins,First]
]


Options[OvertoneModel]=Join[Options[\[Omega]lmn],{"\[Omega]lmnFunction"->\[Omega]lmnPy,"Fit\[Alpha]"->{},"Fit\[Tau]"->{},"AmpPhaseShift"->False,"CounterRotating"->False,"Mode"->{2,2},"Vary\[Omega]"->False,"AnsatzReal"->False,"Mixing"->{False,{2,2}},"ReIm"->False,"AmpPhase"->False,"QualityFactor"->False,"\[Omega]val"->{-0.05,0.05},"Export_\[Omega]val"->False,"FitMassSpin"->False,"xLabel"->"Default","yLabel"->"Default","Tones"->{},"WithCounterRotating"->False,"FixTonesBeyond"->""}];
OvertoneModel[overtones_,pars_,ti_,OptionsPattern[]]:=Block[{af,Global`a,ansatz,ansatzreal,ampansatz,amphase,amphaseshift,counterrotating,w228data,w229data,ex\[Omega]val,fitmassspin,fit\[Alpha],fit\[Tau],im,imm,intws,l,m,maxspin,Mfv,Global`M,lm,modesdata,modesfile,mm,mixing,mode,modto0,
parvals,phaseansatz,qfact,qfactm,qualfactorQ,re,reim,rem,spinweight,tones,Global`t,var,variablemass,varmassint,vary\[Omega],x,xlabel,xcoeffstr,ycoeffstr,y,ylabel,withcounterotating,wlmntables,wlmnmixtables,\[Tau]s,\[Tau]sc,\[Tau]sm,\[Alpha],\[Beta],\[Omega]lmnfunction,
\[Omega]m,\[Omega]s,\[Omega]m\[Tau]sm,\[Omega]sc,\[Eta],\[Chi]1,\[Chi]2,mixmode,\[Omega]val,xc,\[Alpha]s,\[Beta]s,modto0v1,omega,tonesbeyond},
fit\[Alpha]=OptionValue["Fit\[Alpha]"];
fit\[Tau]=OptionValue["Fit\[Tau]"];
mode=OptionValue["Mode"];
vary\[Omega]=OptionValue["Vary\[Omega]"];
mixing=OptionValue["Mixing"];
reim=OptionValue["ReIm"];
amphase=OptionValue["AmpPhase"];
\[Omega]val=OptionValue["\[Omega]val"];
ex\[Omega]val=OptionValue["Export_\[Omega]val"];
modesdata=OptionValue["ModesData"];
modesfile=OptionValue["ModesFile"];
ansatzreal=OptionValue["AnsatzReal"];
qualfactorQ=OptionValue["QualityFactor"];
spinweight=OptionValue["SpinWeight"];
\[Omega]lmnfunction=OptionValue["\[Omega]lmnFunction"];
amphaseshift=OptionValue["AmpPhaseShift"];
counterrotating=OptionValue["CounterRotating"];
fitmassspin=OptionValue["FitMassSpin"];
intws=OptionValue["Interpolate\[Omega]\[Tau]"];
maxspin = OptionValue["MaxSpin"];
xlabel = OptionValue["xLabel"];
ylabel = OptionValue["yLabel"];
tones= OptionValue["Tones"];
tonesbeyond=OptionValue["FixTonesBeyond"];
w228data = OptionValue["w228data"];
w229data = OptionValue["w229data"];
wlmntables = OptionValue["wlmntables"];
wlmnmixtables = OptionValue["wlmnmixtables"];
withcounterotating=OptionValue["WithCounterRotating"];

If[Length@tones==0,tones=Table[n,{n,0,overtones}]];

If[xlabel=="Default",xcoeffstr="x",xcoeffstr=xlabel];
If[ylabel=="Default",ycoeffstr="y",ycoeffstr=ylabel];

If[Not@intws,Global`M=1];
If[Not@intws && \[Omega]lmnfunction!=\[Omega]lmnPy,Print["If Interpolate\[Omega]\[Tau]->True, then you must set \[Omega]lmnfunction==\[Omega]lmnPy"]; Return[{}]];

{lm,mm}=mixing[[2]];

l=mode[[1]];
m=mode[[2]];
{Mfv,af}=pars;

(* Freqs. & damping times *)
If[Length@modesdata==0,
	\[Omega]s=Table[\[Omega]lmnfunction[l,m,n,Mfv,af,"SpinWeight"->spinweight,"Interpolate\[Omega]\[Tau]"->intws,"MaxSpin"->maxspin,"CounterRotating"->counterrotating,"w228data"->w228data,"w229data"->w229data,"ModesFile"->modesfile,"wlmntables"->wlmntables][[1]],{n,tones}];
	If[withcounterotating,\[Omega]sc=Table[\[Omega]lmnfunction[l,m,n,Mfv,af,"SpinWeight"->spinweight,"Interpolate\[Omega]\[Tau]"->intws,"MaxSpin"->maxspin,"CounterRotating"->True,"w228data"->w228data,"w229data"->w229data,"ModesFile"->modesfile,"wlmntables"->wlmntables][[1]],{n,tones}];\[Omega]s=Join[\[Omega]s,\[Omega]sc];];
	var=Flatten@Range[tones+1];
	
	If[vary\[Omega]&&NumberQ[tonesbeyond],\[Omega]s=Table[If[n>tonesbeyond,
	var[[n]]=RandomReal[{1+\[Omega]val[[1]],1+\[Omega]val[[2]]}];,
	var[[n]]=1];omega=\[Omega]lmnfunction[l,m,n,Mfv,af,"SpinWeight"->spinweight,"Interpolate\[Omega]\[Tau]"->intws,"MaxSpin"->maxspin,"CounterRotating"->counterrotating,"w228data"->w228data,"w229data"->w229data,"ModesFile"->modesfile,"wlmntables"->wlmntables][[1]];
	var[[n]]*omega,{n,tones}];,
	vary\[Omega]&&Not@NumberQ[tonesbeyond],\[Omega]s=Table[If[n>0,
	var[[n]]=RandomReal[{1+\[Omega]val[[1]],1+\[Omega]val[[2]]}],
	var[[n]]=1];omega=\[Omega]lmnfunction[l,m,n,Mfv,af,"SpinWeight"->spinweight,"Interpolate\[Omega]\[Tau]"->intws,"MaxSpin"->maxspin,"CounterRotating"->counterrotating,"w228data"->w228data,"w229data"->w229data,"ModesFile"->modesfile,"wlmntables"->wlmntables][[1]];
	var[[n]]*omega,{n,tones}];];
		
	\[Tau]s=Table[\[Omega]lmnfunction[l,m,n,Mfv,af,"SpinWeight"->spinweight,"Interpolate\[Omega]\[Tau]"->intws, "MaxSpin"->maxspin,"CounterRotating"->counterrotating,"w228data"->w228data,"w229data"->w229data,"ModesFile"->modesfile,"wlmntables"->wlmntables][[2]],{n,tones}];
	If[withcounterotating,\[Tau]sc=Table[\[Omega]lmnfunction[l,m,n,Mfv,af,"SpinWeight"->spinweight,"Interpolate\[Omega]\[Tau]"->intws,"MaxSpin"->maxspin,"CounterRotating"->True,"w228data"->w228data,"w229data"->w229data,"ModesFile"->modesfile,"wlmntables"->wlmntables][[2]],{n,tones}];\[Tau]s=Join[\[Tau]s,\[Tau]sc];tones=Join[tones,tones]];
	qfact=\[Omega]s*\[Tau]s;
	,
	\[Omega]s=Table[\[Omega]lmnfunction[l,m,n,Mfv,af,"ModesData"->modesdata[[n+1]],"SpinWeight"->spinweight,"Interpolate\[Omega]\[Tau]"->intws,"MaxSpin"->maxspin,"CounterRotating"->counterrotating,"w228data"->w228data,"w229data"->w229data,"ModesFile"->modesfile,"wlmntables"->wlmntables][[1]],{n,tones}];
	var=Range[0,overtones];
	If[vary\[Omega],\[Omega]s=Table[If[n>0,var[[n+1]]=RandomReal[{1+\[Omega]val[[1]],1+\[Omega]val[[2]]}],var[[1]]=1];var[[n+1]]*\[Omega]lmnfunction[l,m,n,Mfv,af,"ModesData"->modesdata[[n+1]],"SpinWeight"->spinweight,"Interpolate\[Omega]\[Tau]"->intws,"MaxSpin"->maxspin,"CounterRotating"->counterrotating,"w228data"->w228data,"w229data"->w229data,"wlmntables"->wlmntables][[1]],{n,tones}]];
	\[Tau]s=Table[\[Omega]lmnfunction[l,m,n,Mfv,af,"ModesData"->modesdata[[n+1]],"SpinWeight"->spinweight,"Interpolate\[Omega]\[Tau]"->intws,"MaxSpin"->maxspin,"CounterRotating"->counterrotating,"w228data"->w228data,"w229data"->w229data,"ModesFile"->modesfile,"wlmntables"->wlmntables][[2]],{n,tones}];
	qfact=\[Omega]s*\[Tau]s;;	
	];


If[ansatzreal,

If[intws,
ansatz=Sum[x=ToExpression[xcoeffstr<>ToString[tones[[n]]]]; x Exp[-(Global`t-ti)(1/(Global`M*\[Tau]s[[n]](1+ToExpression["\[Beta]"<>ToString[tones[[n]]]])))] (Cos[\[Omega]s[[n]][Global`a]/Global`M(1+ToExpression["\[Alpha]"<>ToString[tones[[n]]]]) (Global`t)+ToExpression["\[Phi]"<>ToString[tones[[n]]]]]),{n,Length@\[Omega]s}];
,
ansatz=Sum[x=ToExpression[xcoeffstr<>ToString[tones[[n]]]]; x Exp[-(Global`t-ti)(1/(\[Tau]s[[n]](1+ToExpression["\[Beta]"<>ToString[tones[[n]]]])))] (Cos[\[Omega]s[[n]](1+ToExpression["\[Alpha]"<>ToString[tones[[n]]]]) (Global`t)+ToExpression["\[Phi]"<>ToString[tones[[n]]]]]),{n,Length@\[Omega]s}];
];
modto0=Complement[Table[i,{i,tones}],fit\[Alpha]];
modto0=Table[ToExpression["\[Alpha]"<>ToString[modto0[[i]]]],{i,Length@modto0}];
ansatz=ansatz/.(Table[modto0[[i]]->0,{i,Length@modto0}]);

modto0=Complement[Table[i,{i,tones}],fit\[Tau]];
modto0=Table[ToExpression["\[Beta]"<>ToString[modto0[[i]]]],{i,Length@modto0}];
ansatz=ansatz/.(Table[modto0[[i]]->0,{i,Length@modto0}]);
Return[If[ex\[Omega]val,{ansatz,var},ansatz]];
,	
If[Not@amphase,
    If[qualfactorQ,
    If[intws,
	ansatz=Sum[If[Not@reim,x=ToExpression[xcoeffstr<>ToString[tones[[n]]]],x=ToExpression[(xcoeffstr<>ToString[tones[[n]]])]+I ToExpression[(ycoeffstr<>ToString[tones[[n]]])]]; x Exp[-(Global`t-ti)(\[Omega]s[[n]][Global`a]/Global`M(1+ToExpression["\[Alpha]"<>ToString[tones[[n]]]])/(qfact[[n]](1+ToExpression["\[Beta]"<>ToString[tones[[n]]]])))] (Cos[\[Omega]s[[n]][Global`a]/Global`M(1+ToExpression["\[Alpha]"<>ToString[tones[[n]]]]) (Global`t)]+I Sin[ \[Omega]s[[n]][Global`a]/Global`M(1+ToExpression["\[Alpha]"<>ToString[tones[[n]]]]) (Global`t)] ),{n,Length@\[Omega]s}];
	If[mixing[[1]],
		\[Omega]m\[Tau]sm=Table[\[Omega]lmnfunction[lm,mm,n,Mfv,af,"ModesFile"->modesfile,"SpinWeight"->spinweight,"Interpolate\[Omega]\[Tau]"->intws,"MaxSpin"->maxspin,"CounterRotating"->counterrotating,"w228data"->w228data,"w229data"->w229data,"ModesFile"->modesfile,"wlmntables"->wlmntables,"wlmnmixtables"->wlmnmixtables,"Mixing"->mixing],{n,tones}];
		\[Omega]m=\[Omega]m\[Tau]sm[[All,1]];
		\[Tau]sm=\[Omega]m\[Tau]sm[[All,2]];
		qfactm=\[Omega]m*\[Tau]sm;
		ansatz=ansatz+Sum[If[Not@reim,x=ToExpression["xm"<>ToString[tones[[n]]]],x=ToExpression["xm"<>ToString[tones[[n]]]]+I ToExpression["ym"<>ToString[tones[[n]]]]];x Exp[-(Global`t-ti)(\[Omega]s[[n]][Global`a]/Global`M(1+ToExpression["\[Alpha]"<>ToString[tones[[n]]]])/(qfactm[[n]](1+ToExpression["\[Beta]"<>ToString[tones[[n]]]])))] (Cos[\[Omega]m[[n]][Global`a]/Global`M (Global`t)]+I Sin[ \[Omega]m[[n]][Global`a]/Global`M (Global`t)] ),{n,Length@\[Omega]s}]]
	,
	ansatz=Sum[If[Not@reim,x=ToExpression[xcoeffstr<>ToString[tones[[n]]]],x=ToExpression[(xcoeffstr<>ToString[tones[[n]]])]+I ToExpression[(ycoeffstr<>ToString[tones[[n]]])]]; x Exp[-(Global`t-ti)(\[Omega]s[[n]](1+ToExpression["\[Alpha]"<>ToString[tones[[n]]]])/(qfact[[n]](1+ToExpression["\[Beta]"<>ToString[tones[[n]]]])))] (Cos[\[Omega]s[[n]](1+ToExpression["\[Alpha]"<>ToString[tones[[n]]]]) (Global`t)]+I Sin[ \[Omega]s[[n]](1+ToExpression["\[Alpha]"<>ToString[tones[[n]]]]) (Global`t)] ),{n,Length@\[Omega]s}];
	If[mixing[[1]],
		\[Omega]m\[Tau]sm=Table[\[Omega]lmnfunction[lm,mm,n,Mfv,af,"ModesFile"->modesfile,"SpinWeight"->spinweight,"Interpolate\[Omega]\[Tau]"->intws,"MaxSpin"->maxspin,"CounterRotating"->counterrotating,"w228data"->w228data,"w229data"->w229data,"ModesFile"->modesfile,"wlmntables"->wlmntables,"wlmnmixtables"->wlmnmixtables,"Mixing"->mixing],{n,tones}];
		\[Omega]m=\[Omega]m\[Tau]sm[[All,1]];
		\[Tau]sm=\[Omega]m\[Tau]sm[[All,2]];
		qfactm=\[Omega]m*\[Tau]sm;
		ansatz=ansatz+Sum[If[Not@reim,x=ToExpression["xm"<>ToString[tones[[n]]]],x=ToExpression["xm"<>ToString[tones[[n]]]]+I ToExpression["ym"<>ToString[tones[[n]]]]];x Exp[-(Global`t-ti)(\[Omega]s[[n]](1+ToExpression["\[Alpha]"<>ToString[tones[[n]]]])/(qfactm[[n]](1+ToExpression["\[Beta]"<>ToString[tones[[n]]]])))] (Cos[\[Omega]m[[n]] (Global`t)]+I Sin[ \[Omega]m[[n]] (Global`t)] ),{n,Length@\[Omega]s}]];];
	,
	If[Not@intws,
    
	ansatz=Sum[If[Not@reim,
	If[n<=tones[[-1]]+1,
	x=ToExpression[xcoeffstr<>ToString[tones[[n]]]];
	\[Alpha]s=ToExpression["\[Alpha]"<>ToString[tones[[n]]]];
	\[Beta]s=ToExpression["\[Beta]"<>ToString[tones[[n]]]];
	,
	x=ToExpression["xc"<>ToString[tones[[n]]]];
	\[Alpha]s=ToExpression["\[Alpha]c"<>ToString[tones[[n]]]];
	\[Beta]s=ToExpression["\[Beta]c"<>ToString[tones[[n]]]];
	];
	,
	
	If[n<=tones[[-1]]+1,
	x=ToExpression[xcoeffstr<>ToString[tones[[n]]]];
	\[Alpha]s=ToExpression["\[Alpha]"<>ToString[tones[[n]]]];
	\[Beta]s=ToExpression["\[Beta]"<>ToString[tones[[n]]]];
	,
	x=ToExpression["xc"<>ToString[tones[[n]]]];
	\[Alpha]s=ToExpression["\[Alpha]c"<>ToString[tones[[n]]]];
	\[Beta]s=ToExpression["\[Beta]c"<>ToString[tones[[n]]]];
	];
	x=ToExpression[(xcoeffstr<>ToString[tones[[n]]])]+I ToExpression[(ycoeffstr<>ToString[tones[[n]]])]];

	x Exp[-(Global`t-ti)(1/(\[Tau]s[[n]](1+\[Beta]s)))] (Cos[\[Omega]s[[n]](1+\[Alpha]s) (Global`t)]+I Sin[ \[Omega]s[[n]](1+\[Alpha]s) (Global`t)] ),{n,Length@\[Omega]s}];

	If[mixing[[1]],
		\[Omega]m\[Tau]sm=Table[\[Omega]lmnfunction[lm,mm,n,Mfv,af,"ModesFile"->modesfile,"SpinWeight"->spinweight,"Interpolate\[Omega]\[Tau]"->intws,"MaxSpin"->maxspin,"CounterRotating"->counterrotating,"w228data"->w228data,"w229data"->w229data,"ModesFile"->modesfile,"wlmntables"->wlmntables,"wlmnmixtables"->wlmnmixtables,"Mixing"->mixing],{n,tones}];
		\[Omega]m=\[Omega]m\[Tau]sm[[All,1]];
		\[Tau]sm=\[Omega]m\[Tau]sm[[All,2]];
		ansatz=ansatz+Sum[If[Not@reim,x=ToExpression["xm"<>ToString[tones[[n]]]],x=ToExpression["xm"<>ToString[tones[[n]]]]+I ToExpression["ym"<>ToString[tones[[n]]]]];x Exp[-(Global`t-ti)/((\[Tau]sm[[n]]))] (Cos[(\[Omega]m[[n]])(Global`t)]+I Sin[(\[Omega]m[[n]])(Global`t)] ),{n,Length@\[Omega]s}]]	
	,
	ansatz=Sum[If[Not@reim,
	If[n<=tones[[-1]]+1,
	x=ToExpression[xcoeffstr<>ToString[tones[[n]]]];
	\[Alpha]s=ToExpression["\[Alpha]"<>ToString[tones[[n]]]];
	\[Beta]s=ToExpression["\[Beta]"<>ToString[tones[[n]]]];
	,
	x=ToExpression["xc"<>ToString[tones[[n]]]];
	\[Alpha]s=ToExpression["\[Alpha]c"<>ToString[tones[[n]]]];
	\[Beta]s=ToExpression["\[Beta]c"<>ToString[tones[[n]]]];
	];
	,
	If[n<=tones[[-1]]+1,
	x=x=ToExpression[(xcoeffstr<>ToString[tones[[n]]])]+I ToExpression[(ycoeffstr<>ToString[tones[[n]]])];
	\[Alpha]s=ToExpression["\[Alpha]"<>ToString[tones[[n]]]];
	\[Beta]s=ToExpression["\[Beta]"<>ToString[tones[[n]]]];
	,
	x=x=ToExpression[("xc"<>ToString[tones[[n]]])]+I ToExpression[("yc"<>ToString[tones[[n]]])];
	\[Alpha]s=ToExpression["\[Alpha]c"<>ToString[tones[[n]]]];
	\[Beta]s=ToExpression["\[Beta]c"<>ToString[tones[[n]]]];
	];];
 
	x Exp[-(Global`t-ti)(1/(Global`M \[Tau]s[[n]][Global`a](1+\[Beta]s)))] (Cos[\[Omega]s[[n]][Global`a]/Global`M(1+\[Alpha]s) (Global`t)]+I Sin[ \[Omega]s[[n]][Global`a]/Global`M(1+\[Alpha]s) (Global`t)] ),{n,Length@\[Omega]s}];
	If[mixing[[1]],
		\[Omega]m\[Tau]sm=Table[\[Omega]lmnfunction[lm,mm,n,Mfv,af,"ModesFile"->modesfile,"SpinWeight"->spinweight,"Interpolate\[Omega]\[Tau]"->intws,"MaxSpin"->maxspin,"CounterRotating"->counterrotating,"w228data"->w228data,"w229data"->w229data,"ModesFile"->modesfile,"wlmntables"->wlmntables,"wlmnmixtables"->wlmnmixtables,"Mixing"->mixing],{n,tones}];
		\[Omega]m=\[Omega]m\[Tau]sm[[All,1]];
		\[Tau]sm=\[Omega]m\[Tau]sm[[All,2]];
		ansatz=ansatz+Sum[If[Not@reim,x=ToExpression["xm"<>ToString[tones[[n]]]],x=ToExpression["xm"<>ToString[tones[[n]]]]+I ToExpression["ym"<>ToString[tones[[n]]]]];x Exp[-(Global`t-ti)/(Global`M*(\[Tau]sm[[n]][Global`a]))] (Cos[(\[Omega]m[[n]][Global`a])/Global`M (Global`t)]+I Sin[(\[Omega]m[[n]][Global`a])/Global`M (Global`t)] ),{n,Length@\[Omega]s}]];
	];
		
	];
	,
	If[qualfactorQ,
	re=Sum[ToExpression[xcoeffstr<>ToString[tones[[n]]]] Exp[-(Global`t-ti)(\[Omega]s[[n]](1+ToExpression["\[Alpha]"<>ToString[tones[[n]]]])/(qfact[[n]](1+ToExpression["\[Beta]"<>ToString[tones[[n]]]])))]Cos[\[Omega]s[[n]](1+ToExpression["\[Alpha]"<>ToString[tones[[n]]]]) (Global`t)+ToExpression["\[Phi]"<>ToString[tones[[n]]]]],{n,Length@\[Omega]s}];
	im=Sum[ToExpression[xcoeffstr<>ToString[tones[[n]]]] Exp[-(Global`t-ti)(\[Omega]s[[n]](1+ToExpression["\[Alpha]"<>ToString[tones[[n]]]])/(qfact[[n]](1+ToExpression["\[Beta]"<>ToString[tones[[n]]]])))]Sin[\[Omega]s[[n]](1+ToExpression["\[Alpha]"<>ToString[tones[[n]]]]) (Global`t)+ToExpression["\[Phi]"<>ToString[tones[[n]]]]],{n,Length@\[Omega]s}];

		If[mixing[[1]],
			\[Omega]m\[Tau]sm=Table[\[Omega]lmnfunction[lm,mm,n,Mfv,af,"ModesFile"->modesfile,"SpinWeight"->spinweight,"Interpolate\[Omega]\[Tau]"->intws,"MaxSpin"->maxspin,"CounterRotating"->counterrotating,"w228data"->w228data,"w229data"->w229data,"ModesFile"->modesfile,"wlmntables"->wlmntables,"wlmnmixtables"->wlmnmixtables],{n,tones}];
			\[Omega]m=\[Omega]m\[Tau]sm[[All,1]]/Global`M;
			\[Tau]sm=\[Omega]m\[Tau]sm[[All,2]]*Global`M;
			qfactm=\[Omega]m*\[Tau]sm;
			rem=Sum[ToExpression[xcoeffstr<>ToString[tones[[n]]]] Exp[-(Global`t-ti)(\[Omega]s[[n]]/Global`M(1+ToExpression["\[Alpha]"<>ToString[tones[[n]]]])/(qfactm[[n]](1+ToExpression["\[Beta]"<>ToString[tones[[n]]]])))] (Cos[\[Omega]m[[n]] (Global`t)]+I Sin[ \[Omega]m[[n]] (Global`t)] ),{n,Length@\[Omega]s}];
			imm=Sum[ToExpression[xcoeffstr<>ToString[tones[[n]]]] Exp[-(Global`t-ti)(\[Omega]s[[n]]/Global`M(1+ToExpression["\[Alpha]"<>ToString[tones[[n]]]])/(qfactm[[n]](1+ToExpression["\[Beta]"<>ToString[tones[[n]]]])))] (Sin[\[Omega]m[[n]] (Global`t)]+I Sin[ \[Omega]m[[n]] (Global`t)] ),{n,Length@\[Omega]s}];
			,
			rem=0;
			imm=0;
			];
	,
	re=Sum[ToExpression[xcoeffstr<>ToString[tones[[n]]]] Exp[-(Global`t-ti)/(Global`M*\[Tau]s[[n]](1+ToExpression["\[Beta]"<>ToString[tones[[n]]]]))]Cos[\[Omega]s[[n]]/Global`M(1+ToExpression["\[Alpha]"<>ToString[tones[[n]]]]) (Global`t)+ToExpression["\[Phi]"<>ToString[tones[[n]]]]],{n,Length@\[Omega]s}];
	im=Sum[ToExpression[xcoeffstr<>ToString[tones[[n]]]] Exp[-(Global`t-ti)/(Global`M*\[Tau]s[[n]](1+ToExpression["\[Beta]"<>ToString[tones[[n]]]]))]Sin[\[Omega]s[[n]]/Global`M(1+ToExpression["\[Alpha]"<>ToString[tones[[n]]]]) (Global`t)+ToExpression["\[Phi]"<>ToString[tones[[n]]]]],{n,Length@\[Omega]s}];

		If[mixing[[1]],
			\[Omega]m\[Tau]sm=Table[\[Omega]lmnfunction[lm,mm,n,Mfv,af,"ModesFile"->modesfile,"SpinWeight"->spinweight,"Interpolate\[Omega]\[Tau]"->intws,"MaxSpin"->maxspin,"CounterRotating"->counterrotating,"w228data"->w228data,"w229data"->w229data,"ModesFile"->modesfile,"wlmntables"->wlmntables,"wlmnmixtables"->wlmnmixtables],{n,tones}];
			\[Omega]m=\[Omega]m\[Tau]sm[[All,1]]/Global`M;
			\[Tau]sm=\[Omega]m\[Tau]sm[[All,2]]*Global`M;
			rem=Sum[ToExpression[xcoeffstr<>ToString[tones[[n]]]] Exp[-(Global`t-ti)/(\[Tau]sm[[n]])] (Cos[\[Omega]m[[n]] (Global`t)]+I Sin[ \[Omega]m[[n]] (Global`t)] ),{n,Length@\[Omega]s}];
			imm=Sum[ToExpression[xcoeffstr<>ToString[tones[[n]]]] Exp[-(Global`t-ti)/(\[Tau]sm[[n]])] (Sin[\[Omega]m[[n]] (Global`t)]+I Sin[ \[Omega]m[[n]] (Global`t)] ),{n,Length@\[Omega]s}];
			,
			rem=0;
			imm=0;
			];
      ];
ampansatz=Sqrt[(re+rem)^2+(im+imm)^2];
phaseansatz=ArcTan[im/re];
ansatz={ampansatz,phaseansatz};
];

modto0v1=Complement[Table[i,{i,tones}],fit\[Alpha]];
modto0=Table[ToExpression["\[Alpha]"<>ToString[modto0v1[[i]]]],{i,Length@modto0v1}];
If[withcounterotating,modto0=Join[modto0,Table[ToExpression["\[Alpha]c"<>ToString[modto0v1[[i]]]],{i,Length@modto0}]]];
ansatz=ansatz/.(Table[modto0[[i]]->0,{i,Length@modto0}]);

modto0v1=Complement[Table[i,{i,tones}],fit\[Tau]];
modto0=Table[ToExpression["\[Beta]"<>ToString[modto0v1[[i]]]],{i,Length@modto0v1}];
If[withcounterotating,
modto0=Join[modto0,Table[ToExpression["\[Beta]c"<>ToString[modto0v1[[i]]]],{i,Length@modto0}]]];
ansatz=ansatz/.(Table[modto0[[i]]->0,{i,Length@modto0}]);
];

If[ex\[Omega]val,{ansatz,var},ansatz]
]



OvertoneFromReImToComplex[vars_,pars_]:=Block[{parsmod,itmax,iters},

itmax=Length[pars]/2;
iters=Table[its-1,{its,itmax}];
parsmod=Table[vars[[2*i+1]]->Sqrt[(pars[[2i+1]]^2+pars[[2i+2]]^2)]Exp[I ArcTan[pars[[2i+2]]/pars[[2i+1]]]],{i,iters}]
];


Options[FitRingdown]=Join[Options[OvertoneModel],{"OldFitPars"->{0,0},"w228data"->{},"w229data"->{},"da"->0.00001,"dm"->0.00001,"OutputGrid"->False,"Boundaries"->{},"wlmntables"->{},"\[Omega]lmnFunction"->\[Omega]lmnPy}];
FitRingdown[data_,nmax_,truepars_,OptionsPattern[]]:=Block[{Global`a,Global`M,Global`t,af,amin,amax,bfmodel,boundaries,da,dm,mfa,mixing,mmin,mmax,oldpars,oldparsnorm,oldparsnorf,out,outgrid,ov,ovi,pars,parsvars,posresmin,res,restab,res2,resall,resmin,resdata,x,y,\[Omega]lmnfunction,wlmntables,wlmnmixtables,\[Omega]lmnFunction,w228data,w229data,times},
oldpars=OptionValue["OldFitPars"];
oldparsnorm=Norm[oldpars/truepars-1];
w228data=OptionValue["w228data"];
w229data=OptionValue["w229data"];
da=OptionValue["da"];
dm=OptionValue["dm"];
outgrid=OptionValue["OutputGrid"];
boundaries=OptionValue["Boundaries"];
\[Omega]lmnfunction=OptionValue["\[Omega]lmnFunction"];
wlmntables = OptionValue["wlmntables"];
\[Omega]lmnFunction = OptionValue["wlmntables"];
mixing = OptionValue["Mixing"];
wlmnmixtables = OptionValue["wlmnmixtables"];

{mfa,af}=truepars;
times=data[[All,1]];
parsvars=Flatten[Table[{ToExpression[("x"<>ToString[n])],ToExpression[("y"<>ToString[n])]},{n,0,nmax}]];
If[mixing[[1]],parsvars=Join[parsvars,Flatten[Table[{ToExpression[("xm"<>ToString[n])],ToExpression[("ym"<>ToString[n])]},{n,0,nmax}]]]];

If[oldparsnorm>= 0.00125 && nmax<5,
Print["Using fitting algorithm"];
parsvars=Join[parsvars,{Global`M,Global`a}];
ov=OvertoneModel[nmax,{mfa,af},0,"Fit\[Alpha]"->{},"Mode"->{2,2},"SpinWeight"->-2,"\[Omega]lmnFunction"->\[Omega]lmnfunction,"Interpolate\[Omega]\[Tau]"->True,"ReIm"->True,"wlmntables"->wlmntables,"Mixing"->mixing,"wlmnmixtables"->wlmnmixtables];
(*res=Sqrt[Total@(Abs[bfmodel[[All,2]]-data[[All,2]]]^2)];*)
resall=CNMinimize[data[[All,2]],ov,parsvars,{Global`t,times},"Bounds"->{0.7<= Global`M<= 1.5,0.<= Global`a<= 0.99},Method->"NelderMead",MaxIterations->100000];
pars={Global`M,Global`a}/.resall[[2]];
resdata=Transpose[{times,ov/.resall[[2]]/.Global`t->times}];
(*res2=Total@(Re[resdata[[All,2]]-data[[All,2]]]^2+Im[resdata[[All,2]]-data[[All,2]]]^2);*)
res2=1-EasyMatchT[data,resdata,times[[1]],times[[1]]+90];
res=Join[pars,{res2}];
If[MemberQ[{0.7,1.5},pars[[1]]]||MemberQ[{0,0.99},pars[[2]]],out=1;Print[Style["Parameter estimate touching the boundaries at n = "<>ToString[nmax]<>". Consider to broaden the boundaries.",Red]],out=0;];
,
Print["Using grid algorithm"];
If[Length@boundaries==0,
amin=oldpars[[2]]*(0.995);
amax=oldpars[[2]]*(1.005);
mmin=oldpars[[1]]*(0.995);
mmax=oldpars[[1]]*(1.005);,
amin=boundaries[[2,1]];
amax=boundaries[[2,2]];
mmin=boundaries[[1,1]];
mmax=boundaries[[1,2]];
];

Print["M bounds: ",{mmin,mmax}];
Print["a bounds: ",{amin,amax}];


	ovi=OvertoneModel[nmax,{mfa,af},0,"Fit\[Alpha]"->{},"Mode"->{2,2},"SpinWeight"->-2,"\[Omega]lmnFunction"->\[Omega]lmnfunction,"ReIm"->False,"w228data"->w228data,"w229data"->w229data,"Interpolate\[Omega]\[Tau]"->True,"wlmntables"->wlmntables,"Mixing"->mixing,"wlmnmixtables"->wlmnmixtables];
	restab=Flatten[Table[
	ov=ovi/.Global`M->mass/.Global`a->spin;
	res=NonlinearModelFit[data,ov,parsvars,Global`t]["BestFitParameters"];
	pars=Norm[{mass,spin}-{mfa,af}];
	resdata=Transpose[{times,ov/.res/.Global`t->times}];
	res=Total@(Re[resdata[[All,2]]-data[[All,2]]]^2+Im[resdata[[All,2]]-data[[All,2]]]^2);
	 bfmodel=Transpose[{times,ov/.pars/.Global`t->times}];
	(*res=Sqrt[Total@(Abs[bfmodel[[All,2]]-data[[All,2]]]^2)];*)
	res=1-EasyMatchT[data,bfmodel,times[[1]],times[[1]]+90];
	{mass,spin,res,pars},{mass,mmin,mmax,dm},{spin,amin,amax,da}],1];
	resmin=Min[restab[[All,3]]];
	Quiet[posresmin=Position[restab,_?(#[[3]]==resmin&)]];
	pars=restab[[posresmin[[1,1]]]][[1;;2]];
	res2=resmin;
	res=Join[pars,{res2}];
	If[MemberQ[{mmin,mmax},pars[[1]]]||MemberQ[{amin,amax},pars[[2]]],out=1;Print[Style["Parameter estimate touching the boundaries at n = "<>ToString[nmax]<>". Consider to broaden the boundaries.",Red]],out=0;];
];

Which[oldparsnorm>= 0.00125 && nmax<5, Join[res,{out},{resall[[2]]}],True,If[outgrid,Join[res,{out},{{restab}},{resall[[2]]}],Join[res,{out},{resall[[2]]}]]]
]


(* ::Input::Initialization:: *)
Options[FitRingdownGrid]=Join[Options[OvertoneModel],{"Mode"->{2,2},"SpinRange"-> {0.,1.},"SpinThresholds"-> {0.,0.99},"Iterations"-> 7,"MassStepInit"-> 0.05,"SpinStepInit"-> 0.05,"MassSampling"-> 20,"SpinSampling"-> 20,"NeighbourPointsMass"->2,"NeighbourPointsSpin"->2,"w228data"-> {},"w229data"->{},"\[Omega]lmnFunction"-> \[Omega]lmnPy, "TrueParameters"->{1,0},"wlmntables"->{},"Verbose"->False,"Tones"->{},"FixTonesBeyond"->"" }];
FitRingdownGrid[thedata_,nmax_,thetmin_,massrange_,OptionsPattern[]]:=
Block[{w228data=OptionValue["w228data"],w229data=OptionValue["w229data"],\[Omega]lmnfunc = OptionValue["\[Omega]lmnFunction"],themode = OptionValue["Mode"],ampslist=Table[ToExpression["x"<>ToString[i]],{i,0,nmax}],mminInit=massrange[[1]],mmaxInit=massrange[[2]],mmin,mmax,aminInit=OptionValue["SpinRange"][[1]],amaxInit=OptionValue["SpinRange"][[2]],amin,amax,athreshmin = OptionValue["SpinThresholds"][[1]],athreshmax = OptionValue["SpinThresholds"][[2]],mstep=OptionValue["MassStepInit"],astep=OptionValue["SpinStepInit"],msamp = OptionValue["MassSampling"],asamp = OptionValue["SpinSampling"],nbneighboursm = OptionValue["NeighbourPointsMass"],nbneighboursa = OptionValue["NeighbourPointsSpin"],itmax=OptionValue["Iterations"],tones=OptionValue["Tones"],tonesbeyond=OptionValue["FixTonesBeyond"],truepars=OptionValue["TrueParameters"],wlmntables=OptionValue["wlmntables"],wlmnmixtables = OptionValue["wlmnmixtables"],verbose=OptionValue["Verbose"],withcounterotating=OptionValue["WithCounterRotating"],i,data,rest,restTotal={},ov,curDistance,pars,bfmodel,res,resmin,distancemin,posresmin,posdistancemin,bestmass,bestspin,bestpars,bestbic,Global`t,datam,times,mixing,lenc,lend,vary\[Omega],wc228data},

mixing = OptionValue["Mixing"];
vary\[Omega]=OptionValue["Vary\[Omega]"];
wc228data=OptionValue["wc228data"];
data=Select[thedata,#[[1]]>=thetmin&];
times=data[[All,1]];
lend=Length[data];
If[mixing[[1]],ampslist=Join[ampslist,Table[ToExpression["xm"<>ToString[n]],{n,0,nmax}]]];
If[withcounterotating,ampslist=Join[ampslist,Table[ToExpression["xc"<>ToString[n]],{n,0,nmax}]]];
If[verbose,Print[ampslist]];
lenc=Length[ampslist];
For[{i=0;mmin=mminInit;mmax=mmaxInit;amin=aminInit;amax=amaxInit},i<itmax,i++,
rest=Flatten[Table[
spin=Max[spin,athreshmin]; spin=Min[spin,athreshmax];spin=Round[spin,10.^-15];mass=Round[mass,10.^-15];

If[NumberQ@tonesbeyond && nmax> tonesbeyond,
ov=OvertoneModel[tonesbeyond,{mass,spin},0,"Fit\[Alpha]"->{},"Mode"->{2,2},"SpinWeight"->-2,"\[Omega]lmnFunction"->\[Omega]lmnfunc,"Interpolate\[Omega]\[Tau]"->False,"ReIm"->False,"wlmntables"->wlmntables,"Mixing"->mixing,"wlmnmixtables"->wlmnmixtables,"WithCounterRotating"->withcounterotating,"Vary\[Omega]"->vary\[Omega],"FixTonesBeyond"->tonesbeyond,"wc228data"->wc228data];
ov=ov+OvertoneModel[nmax,truepars,0,"Fit\[Alpha]"->{},"Mode"->{2,2},"SpinWeight"->-2,"\[Omega]lmnFunction"->\[Omega]lmnfunc,"Interpolate\[Omega]\[Tau]"->False,"ReIm"->False,"wlmntables"->wlmntables,"Mixing"->mixing,"wlmnmixtables"->wlmnmixtables,"WithCounterRotating"->withcounterotating,"Vary\[Omega]"->vary\[Omega],"wc228data"->wc228data,"FixTonesBeyond"->tonesbeyond,"Tones"->Table[i,{i,tonesbeyond+1,nmax}]];
,
ov=OvertoneModel[nmax,{mass,spin},0,"Fit\[Alpha]"->{},"Mode"->{2,2},"SpinWeight"->-2,"\[Omega]lmnFunction"->\[Omega]lmnfunc,"Interpolate\[Omega]\[Tau]"->False,"ReIm"->False,"wlmntables"->wlmntables,"Mixing"->mixing,"wlmnmixtables"->wlmnmixtables,"WithCounterRotating"->withcounterotating,"wc228data"->wc228data];
];

pars=NonlinearModelFit[data,ov,ampslist,Global`t]["BestFitParameters"];
curDistance=Norm[{mass,spin}-truepars];
bfmodel=Transpose[{data[[All,1]],ov/.pars/.Global`t->times}];
res=1-EasyMatchT[data,bfmodel,times[[1]],times[[1]]+1000];
(*res=Sqrt[Total@(Abs[bfmodel[[All,2]]-data[[All,2]]]^2)];*)
{mass,spin,res,curDistance,pars},{mass,mmin,mmax,mstep},{spin,amin,amax,astep}],1];
restTotal = Join[restTotal,rest[[;;,;;4]]];
resmin=Min[rest[[All,3]]];
distancemin=If[i==0,Min[rest[[All,4]]],Min[distancemin,Min[rest[[All,4]]]]];
posresmin=Position[rest[[All,3]],_?(# == resmin&)];
posdistancemin=Position[rest[[All,4]],_?(#==distancemin&)];
bestmass=rest[[posresmin[[1,1]],1]];
bestspin=rest[[posresmin[[1,1]],2]];
bestpars = rest[[posresmin[[1,1]],5]];
If[bestmass==mmin||bestmass==mmax,Print[Style["Warning! Mass hit an edge (iteration "<>ToString[i+1]<>" of "<>ToString[itmax]<>").",Orange]]];
If[bestspin==amin||bestspin==amax||bestspin==athreshmin||bestspin==athreshmax,Print[Style["Warning! Spin hit an edge (iteration "<>ToString[i+1]<>" of "<>ToString[itmax]<>").",Orange]]];
mmin=Max[bestmass-nbneighboursm*mstep,mminInit];
mmax=Min[bestmass+nbneighboursm*mstep,mmaxInit];
amin=Max[bestspin-nbneighboursa*astep,athreshmin,aminInit];
amax=Min[bestspin+nbneighboursa*astep,athreshmax,amaxInit];
If[verbose,Print[mmin,"  ",bestmass,"  ",mmax,"    ",amin,"  ",bestspin,"  ",amax,"         ",mstep,"    ",astep]];
If[i < itmax-1,
mstep=mstep*2.*nbneighboursm/msamp;
astep=astep*2.*nbneighboursa/asamp;
]
];
restTotal=Sort[DeleteDuplicatesBy[restTotal,#[[1;;2]]&]];
ov=OvertoneModel[nmax,{bestmass,bestspin},0,"Fit\[Alpha]"->{},"Mode"->{2,2},"SpinWeight"->-2,"\[Omega]lmnFunction"->\[Omega]lmnfunc,"Interpolate\[Omega]\[Tau]"->False,"ReIm"->False,"wlmntables"->wlmntables,"Mixing"->mixing,"wlmnmixtables"->wlmnmixtables];
bfmodel=Transpose[{times,ov/.bestpars/.Global`t->times}];
bestbic = lend + lend *Log[2\[Pi]]+Log[lend]*(2*lenc+1)+lend *Log[Total@(Abs[bfmodel[[All,2]]-data[[All,2]]]^2)/lend];{restTotal,bestmass,bestspin,mstep,astep,Norm[{bestmass,bestspin}-truepars],resmin,distancemin,bestbic,bestpars}
]


Options[AICcRes]=Options[AICcRes];
AICcRes[res_,coeff_]:=Module[{err,n,newfit,bracketedvars,ress,weigths},
err=1;
n=Length@res;
ress=Total[err (Abs[res])^2];
n + n Log[2\[Pi]]+n Log[ress/n]+(2*coeff(coeff+1) )/(n - coeff -1)

]


Options[BICRes]=Options[AICcRes];
BICRes[res_,coeff_]:=Module[{err,fact1,fact2,n,newfit,bracketedvars,ress,weigths},
err=1;
n=Length@res;
ress=Total[err (Abs[res])^2];
n + n Log[2\[Pi]]+n Log[ress/n]+Log[n](coeff+1)
]


Options[PValueTest]={"IRoot"->10};
PValueTest[dfnum_,dfden_,signl_,OptionsPattern[]]:=Module[{xmax,iroot},
iroot=OptionValue["IRoot"];
xmax/.FindRoot[NIntegrate[PDF[FRatioDistribution[dfnum,dfden],x],{x,0,xmax}]==1-signl,{xmax,iroot}]]


HessianH[f_,t_List?VectorQ]:=D[f,{t,2}]


Options[CovarianceMatrix]={"Tolerance"->10^(-32)};
CovarianceMatrix[res_,pars_,truepars_,OptionsPattern[]]:=Module[{length,hessian,tol,resreim,Xx,Xxre,Xxim},

tol=OptionValue["Tolerance"];
length=Length@res;
Xxre=Total[(ComplexExpand/@Re[res])^2];
Xxim=Total[(ComplexExpand/@Im[res])^2];
(*Xx=Total[Xxre^2+Xxim^2];*)
hessian=Rationalize[HessianH[Log[Xxre],pars]/.truepars,tol]+Rationalize[HessianH[Log[Xxim],pars]/.truepars,tol];

(2 Inverse[hessian])/(length-Length@pars)*1.]


Options[FisherMatrix]={"Times"->{}};
FisherMatrix[f_,par_List?VectorQ,truepars_List?VectorQ,OptionsPattern[]]:=Block[{derre,derim,fm,fmim,fmre,fre,fim,times},

times=OptionValue["Times"];
fre=ComplexExpand[Re[f]];
fim=ComplexExpand[Im[f]];

derre=D[fre,{par,1}];
fmre=Outer[Times,derre,derre];

derim=D[fim,{par,1}];
fmim=Outer[Times,derim,derim];

If[Length@times!=0,
fm=2 Table[Total[fmre[[i,j]]/.t->times/.truepars]+Total[fmim[[i,j]]/.t->times/.truepars],{i,Length@par},{j,Length@par}];];

2*Inverse[fm]/(Length@times-Length@par)*1.
]


CovarianceMatrixFromLikelihood[data_]:=Module[{cnorm,datan,datanfreq,datain,dom,kdist,vars,varsdom},

datain=Interpolation@data;
dom=InterpolationDomain[datain];

datan=data;
vars=Table[ToExpression["x"<>ToString[i]],{i,Length@data[[1]]-1}];
varsdom=Table[{ToExpression["x"<>ToString[i]],dom[[i,1]],dom[[i,2]]},{i,Length@vars}];

cnorm=NIntegrate[datain@@vars,##]&@@varsdom;
datan[[All,-1]]=datan[[All,-1]]/cnorm;
datanfreq=datan[[All,1;;-2]]datan[[All,-1]];
kdist=KernelMixtureDistribution[datanfreq];

2 Covariance[kdist]

]


Options[CorrelationMatrix]=Options[CovarianceMatrix];
CorrelationMatrix[res2_,pars_,truepars_,OptionsPattern[]]:=Module[{Ds,Dsi,covmat,length,hessian,tol,Xx},

tol=OptionValue["Tolerance"];

covmat=CovarianceMatrix[res2,pars,truepars];
Ds=Rationalize[DiagonalMatrix[Diagonal[Sqrt[Re@covmat]]],tol];
Dsi=Inverse[Ds];

Dsi.covmat.Dsi
]


LogLikelihoodDist[data_,ansatz_,vars_,x_]:=Module[{ansatzlist},
ansatzlist=ansatz/.vars/.x->data[[All,1]];
-Total[(Re[ansatzlist-data[[All,2]]]^2+Im[ansatzlist-data[[All,2]]]^2)]]


Options[ComputeFitBands]={"ConfidenceLevel"->0.9};
ComputeFitBands[data_,ansatz_,vars_,pars_,OptionsPattern[];]:=Module[{ansatzv,colevel,covmat,dvec,lower,res,resce,resre,resim,times,tval,Xx,upper,a1},

colevel=OptionValue["ConfidenceLevel"];
tval=StudentTCI[0,1,Length@vars,ConfidenceLevel->colevel][[2]];
res=(ansatz/.t->data[[All,1]])-data[[All,2]];

resce=ComplexExpand@Total[res];
(resre=Simplify[Re[ComplexExpand[resce]],Element[vars,Reals]]);
(resim=Simplify[Im[ComplexExpand[resce]],Element[vars,Reals]]);
Xx=resre^2+resim^2;

covmat=CovarianceMatrix[Xx,Length@res,vars,pars];
times=data[[All,1]];

lower=Table[{times[[i]],ansatzv=ansatz/.t->times[[i]];dvec=Table[D[ansatzv,vars[[j]]],{j,Length@vars}]/.pars;(ansatzv/.pars)-tval Sqrt[dvec.covmat.dvec]},{i,Length@times}];
upper=Table[{times[[i]],ansatzv=ansatz/.t->times[[i]];dvec=Table[D[ansatzv,vars[[j]]],{j,Length@vars}]/.pars;(ansatzv/.pars)+tval Sqrt[dvec.covmat.dvec]},{i,Length@times}];
{lower,upper}
]


(* ::Code::Initialization:: *)
End[];
EndPackage[];
